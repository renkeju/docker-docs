
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Docker &#8212; Docker alphe documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="docker">
<h1>Docker<a class="headerlink" href="#docker" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>总体架构<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<img alt="../../_images/docker-architecture.jpg" src="../../_images/docker-architecture.jpg" />
<p>docker 是一个 C/S 模式的架构，后端是一个松耦合架构，模块各司其职。</p>
<ol class="arabic simple">
<li><p>用户是使用 Docker Client 与 Docker Daemon 建立通讯，并发送请求给后者。</p></li>
<li><p>Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Server 的功能使其可以接收 Docker Client 的请求。</p></li>
<li><p>Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p></li>
<li><p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 graphdriver 将下载镜像以 Graph 的形式存储；</p></li>
<li><p>当需要为 Docker 创建网络环境时，通过网络管理驱动 networkdriver 创建并配置 Docker 容器网络环境；</p></li>
<li><p>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 execdriver 来完成。</p></li>
<li><p>libcontainer 是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</p></li>
</ol>
<div class="section" id="docker-client">
<h3>docker Client [发起请求]<a class="headerlink" href="#docker-client" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Docker Client 是和 Docker Daemon 建立通信的客户端。用户使用的可执行文件为 docker（类似可执行脚本的命令），docker 命令后接参数的形式来实现一个完整的请求命令（例如 docker images，docker 为命令可不变，images 为参数可变）。</p></li>
<li><p>Docker Client 可以通过以下三种方式和 Docker Daemon 建立通信</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tcp://host:port</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unix://path_to_socket</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fd://sockerfd</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Docker Client 发送容器管理请求后，由 Docker Daemon 接受并处理请求，当 Docker Client 接收到返回的请求响应并简单处理后，Docker Client 一次完整的生命周期就结束了。【一次完整的请求：发送请求→处理请求→返回结果】，于传统的C/S架构请求流程并无不同。</p></li>
</ol>
</div>
<div class="section" id="docker-daemin">
<h3>Docker Daemin [后台守护进程]<a class="headerlink" href="#docker-daemin" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Docker Daemon 的架构图</p>
<blockquote>
<div><img alt="../../_images/docker-daemon.jpg" src="../../_images/docker-daemon.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p>docker Server [调度分发请求]</p>
<blockquote>
<div><ul>
<li><p>Docker Server 的架构图</p>
<blockquote>
<div><img alt="../../_images/docker-server.jpg" src="../../_images/docker-server.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li><p>Docker Server 相当于 C/S 架构的服务端。功能为接收并调度分发 Docker Client 发送的请求。接收请求后，Server 通过路由于分发调度，找到相应的 Handler 并执行请求。</p></li>
<li><p>在 Docker 启动过程中，通过包 gorilla/mux，创建一个 mux.Router，提供请求的路由功能。在 Golang 中，gorilla/mux 是一个强大的 URL 路由器以及调度分发器。该 mux.Router 中添加了众多的路由项，每一个路由项由 HTTP 请求方法（PUTPOSTGETDELETE）、URL、Handler 三部分组成</p></li>
<li><p>创建完 mux.Router 之后，Docker 将 Server 的监听地址以及 mux.Router 作为参数，创建一个 httpSrv=http.Server{}，最终执行 httpSrv.Server() 为请求服务。</p></li>
<li><p>在 Server 的服务过程中，Server 在 Listener 上接受 Docker Client 的访问请求，并创建一个全新的 goroutine 来服务该请求。在 goroutine 中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的 Handler 来处理该请求，最后 Handler 处理完请求之后回复该请求。</p></li>
</ol>
</div></blockquote>
</li>
<li><p>Engine</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Engine 是 Docker 架构中的运行引擎，同时也是 Docker 运行的核心模块。它扮演 Docker container 存储仓库的角色，并且通过执行 job 的方式来操纵管理这些容器。</p></li>
<li><p>在 Engine 数据结构的设计于实现过程中，有一个 handler 对象。该 handler 对象存储的都是关于众多特定 job 的 handler 处理访问。举例说明，Engine 的 handler 对象中有一项为：<code class="docutils literal notranslate"><span class="pre">{&quot;create&quot;:</span> <span class="pre">daemin.ContainerCreate,}</span></code> ，则说明当名为”create“的job在运行是，执行的是 daemon.ContainerCreate 的 handler。</p></li>
</ol>
</div></blockquote>
</li>
<li><p>job</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>一个 Job 可以认为是 Docker 架构中 Engine 内部最基本的工作执行单元。Docker 可以做的每一项工作，都可以抽象为一个 job。例如：在容器内部运行一个进程，这是一个 job；创建一个新的容器，这是一个 job。Docker Server 的运行过程也是一个 Job，名为 serverapi。</p></li>
<li><p>Job 的设计者，把 Job 设计的与 Unix 进程相仿。比如说： job 有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</p></li>
</ol>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="docker-registry">
<h3>Docker Registry [镜像注册中心]<a class="headerlink" href="#docker-registry" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Docker Registry 是一个存储容器镜像的仓库（注册中心），可以理解为云端镜像仓库，按 repository 来分类，docker pull 按照 [repository]:[tag] 来精确定义一个 image。</p></li>
<li><p>在 Docker 的运行过程中，Docker Daemon 会与 Docker Registry 通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的 job 名称分别为 “search”，“pull” 与 “push”</p></li>
<li><p>可分为公有仓库（docker hub）和私有仓库</p></li>
</ol>
</div>
<div class="section" id="graph-docker">
<h3>Graph [docker 内部数据库]<a class="headerlink" href="#graph-docker" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Graph 的架构图</p>
<blockquote>
<div><img alt="../../_images/graph-architecture.jpg" src="../../_images/graph-architecture.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p>Repository</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>已下载镜像的保管者（包括下载镜像和 dockerfile 构建的镜像）</p></li>
<li><p>一个 repository 表示某类镜像的仓库（例如 Ubuntu），同一个 repository 内的镜像用 tag 来区分（表示同一类镜像的不同标签或版本）。一个 Registry 包含多个 repository，一个 repository 包含同类型的多个 image。</p></li>
<li><p>镜像的存储类型有 aufs，devicemapper，Btrfs，vfs 等。其中 centos 系统使用 devicemapper 的存储类型。</p></li>
<li><p>同时在 Graph 的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体 rootfs。</p></li>
</ol>
</div></blockquote>
</li>
<li><p>GraphDB</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>已下载容器镜像之间关系的记录者。</p></li>
<li><p>GraphDB 是一个构建在 SQLite 之上的小型图形数据库，实现了节点的命名以及节点之间关联关系的记录。</p></li>
</ol>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="driver">
<h3>Driver [执行部分]<a class="headerlink" href="#driver" title="Permalink to this headline">¶</a></h3>
<p>Driver 是 Docker 架构中的驱动模块。通过 Driver 驱动，Docker 可以实现对 Docker 容器执行环境的定制。即 Graph 负责镜像的存储，Driver 负责容器的执行。</p>
<ol class="arabic">
<li><p>graphdriver</p>
<blockquote>
<div><ul>
<li><p>graphdriver 架构图</p>
<blockquote>
<div><img alt="../../_images/graphdriver.jpg" src="../../_images/graphdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li><p>graphdriver 主要用于完成容器镜像的管理，包括存储与获取。</p></li>
<li><p>存储：docker pull 下载的镜像由 graphdriver 存储导本地的指定目录（Graph 中）。</p></li>
<li><p>获取：docker run (create) 用镜像来创建容器的时候由 graphdriver 到本地 Graph 中获取镜像。</p></li>
</ol>
</div></blockquote>
</li>
<li><p>networkdriver</p>
<blockquote>
<div><ul>
<li><p>networkdriver 的架构图</p>
<blockquote>
<div><img alt="../../_images/networkdriver.jpg" src="../../_images/networkdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p>networkdriver 的用途是完成docker容器网络环境的配置，其中包括：</p>
<blockquote>
<div><ul class="simple">
<li><p>Docker 启动时为 Docker 环境创建网桥</p></li>
<li><p>Docker 容器创建时为其创建专属虚拟网卡设备</p></li>
<li><p>Docker 容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</li>
<li><p>execdriver</p>
<blockquote>
<div><ul>
<li><p>execdriver 的结构图</p>
<blockquote>
<div><img alt="../../_images/execdriver.jpg" src="../../_images/execdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li><p>execdriver 作为 Docker 容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。</p></li>
<li><p>现在 execdriver 默认使用 native 驱动，不依赖于 LXC。</p></li>
</ol>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="libcontainer">
<h3>libcontainer [函数库]<a class="headerlink" href="#libcontainer" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>libcontainer 的架构图</p>
<blockquote>
<div><img alt="../../_images/networkdriver.jpg" src="../../_images/networkdriver.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic simple">
<li><p>libcontainer 是 Docker 架构中一个使用 Go 语言设计实现的库，设计初衷时希望该库可以不依靠任何依赖，直接访问内核中于容器相关的 API。</p></li>
<li><p>Docker 可以直接调用 libcontainer，而最终操作容器的 namespace、cgroups、apparmor、网络设备以及防火墙规则等。</p></li>
<li><p>libcontainer 提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer 屏蔽了 Docker 上层对容器的直接管理。</p></li>
</ol>
</div>
<div class="section" id="docker-container">
<h3>Docker container [服务交付的最终形式]<a class="headerlink" href="#docker-container" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>container 架构</p>
<blockquote>
<div><img alt="../../_images/container.jpg" src="../../_images/container.jpg" />
</div></blockquote>
</li>
</ul>
<ol class="arabic">
<li><p>Docker container（Docker 容器）是Docker架构中服务交付的最终体现形式</p></li>
<li><p>Docker 按照用户的需求于指令，定制相应的 Docker 容器</p>
<blockquote>
<div><ul class="simple">
<li><p>用户通过指定容器镜像，使得 Docker 容器可以自定义 rootfs 等文件系统</p></li>
<li><p>用户通过指定计算资源的配额，使得 Docker 容器使用指定的计算资源</p></li>
<li><p>用户通过配置网络及其安全策略，使得 Docker 容器拥有独立且安全的网络环境</p></li>
<li><p>用户通过指定运行的命令，使得 Docker 容器执行指定的工作</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</div>
</div>
<div class="section" id="id2">
<h2>基础用法<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>安装<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>依赖的基础环境</p>
<blockquote>
<div><ul class="simple">
<li><p>64 bits CPU</p></li>
<li><p>Linux Kernel 3.10+</p></li>
<li><p>Linux Kernel cgroups and namespaces</p></li>
</ul>
</div></blockquote>
</li>
<li><p>CentOS 7+</p>
<blockquote>
<div><ul>
<li><p>“Extras” repository</p>
<blockquote>
<div><p>不建议通过 CentOS 默认仓库安装 Docker，版本过旧</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Docker Daemon</p>
<blockquote>
<div><ul class="simple">
<li><p>systemctl start docker.service</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>个人推荐使用 daocloud 安装 docker，安装方式详见 <a class="reference external" href="https://download.daocloud.io/Docker_Mirror/Docker">daocloud 产品中心 docker 安装方式</a></p>
</div>
<div class="section" id="id4">
<h3>docker 程序环境<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>docker 环境配置都可以由 <code class="docutils literal notranslate"><span class="pre">/etc/docker/daemon.none</span></code> 这个文件所控制。docker 安装后默认没有 daemon.none 这个配置文件，需要手工创建。</p>
<p>一般情况下，配置文件 daemin.none 中配置的项目参数，在启动参数中同样适用，有些可能不一样（具体可以查看官方文档），但需要注意的一点，配置文件中如果已经由摸个配置项，则无法在启动参数中增加，会出现冲突的错误。</p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>如果在 daemon.none 文件中进行配置，需要 docker 版本高于 1.12.6（在这个版本不生效，1.13.1 以上是生效的）</p>
</div>
<ul>
<li><p>指定网桥网络</p>
<blockquote>
<div><p>给 docker0 分配特定的IP地址，并设置子网掩码</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;bip&quot;: &quot;192.168.199.5/24&quot;
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>指定网桥网络范围</p>
<blockquote>
<div><p>限制 docker0 分配给容器的IP的范围。必须是 docker0 所在网络范围内的一个子网，或是由 <code class="docutils literal notranslate"><span class="pre">--bridge</span></code> 指定的网桥的IP所在网络范围内的一个子网。此后，为容器分配IP时就会从这个范围内选择一个可用的IP地址。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;fixed-cidr&quot;: &quot;10.20.0.0/16&quot;,
    &quot;fixed-cide-v6&quot;: &quot;2001:db8::/64&quot;
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>最大传输单元</p>
<blockquote>
<div><p>覆盖 docker0 默认的最大传输单元</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;mtu&quot;: 1500
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>指定 DNS</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;dns&quot;: [&quot;8.8.8.8&quot;, &quot;8.8.4.4&quot;]
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>指定监听模式</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;hosts&quot;: [&quot;tcp://0.0.0.0:2376&quot;, &quot;unix:///var/run/docker.sock&quot;]
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>镜像加速器</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// 配置单个
{
    &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}

// 配置多个
{
    &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn/&quot;]
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>日志</p>
<blockquote>
<div><p>log-level 的有效值包括：</p>
<ul class="simple">
<li><p>debug</p></li>
<li><p>info</p></li>
<li><p>warn</p></li>
<li><p>error</p></li>
<li><p>fatal</p></li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;debug&quot;: true,
    &quot;log-level&quot;: &quot;info&quot;
}
</pre></div>
</div>
<p>指定日志格式、大小和数量等。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;log-driver&quot;: &quot;json-file&quot;,
    &quot;log-opts&quot;: {
        &quot;max-size&quot;: &quot;5m&quot;,
        &quot;max-file&quot;: &quot;5&quot;
    }
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>监控 Prometheus</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/admin/prometheus/#configure-docker">https://docs.docker.com/engine/admin/prometheus/#configure-docker</a></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;metrics-addr&quot;: &quot;127.0.0.1:9323&quot;,
    &quot;experimental&quot;: true
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>保持容器在线</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/admin/live-restore/#enable-the-live-restore-option">https://docs.docker.com/engine/admin/live-restore/#enable-the-live-restore-option</a></p>
<p>当 dockerd 进程死掉后，依旧保持容器存活。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;live-restore&quot;: true
}
</pre></div>
</div>
<p>Linux 重载 docker daemon</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ sudo <span class="nb">kill</span> -SIGHUP <span class="k">$(</span>pidof dockerd<span class="k">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>信任私有仓库地址</p>
<blockquote>
<div><p>docker 默认只信任 HTTPS 协议私有镜像仓库，如果搭建内网私有镜像仓库使用 HTTP 协议，需要指定信任仓库。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;insecure-registries&quot;: [ &quot;10.10.172.203:5000&quot; ]
}
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>设置 镜像、容器、卷 存放目录和驱动</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/admin/systemd/#runtime-directory-and-storage-driver">https://docs.docker.com/engine/admin/systemd/#runtime-directory-and-storage-driver</a></p>
<p>下述两个参数可以单独使用</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;graph&quot;: &quot;/mnt/docker-data&quot;,
    &quot;storage-driver&quot;: &quot;overlay&quot;
}
</pre></div>
</div>
<p>graph 设置存放目录 —— Docker Root Dir /mnt/docker-data
storage-driver 设置存储驱动 —— Storage Driver overlay</p>
</div></blockquote>
</li>
<li><p>user namespace remap</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.docker.com/engine/security/userns-remap/#enable-userns-remap-on-the-daemon">https://docs.docker.com/engine/security/userns-remap/#enable-userns-remap-on-the-daemon</a></p>
<p>安全设置：用户空间重映射</p>
<p>userns-remap 的值可以是 如果值字段 只有 一个值，那么该字段表示组。如果需要同时指定 用户和组，需要使用 冒号 分割，格式为 用户:组</p>
<ul>
<li><p>组</p></li>
<li><p>用户:组</p></li>
<li><p>组 或 用户 的值可以是组或用户的 名称 或 ID</p>
<blockquote>
<div><ul class="simple">
<li><p>testuser</p></li>
<li><p>testuser:testuser</p></li>
<li><p>1001</p></li>
<li><p>1001:1001</p></li>
<li><p>testuser:1001</p></li>
<li><p>1001:testuser</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;userns-remap&quot;: &quot;testuser&quot;
}

// 或同时指定 用户和组，且使用 名称和ID
{
    &quot;userns-remap&quot;: &quot;testuser:1001&quot;
}
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dockerd --userns-remap=&quot;testuser:testuser&quot;
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>userns-remap 使用不多，但并不是不重要。目前不是默认启用的原因时因为一些应用会假定 uid 0 的用户拥有特殊能力，从而导致假定失败，然后报错退出。所以如果要启用 user id remap，你要充分测试一下。但是启用 uid remap 的安全性提高是明显的。</p>
</div>
</div></blockquote>
</li>
</ul>
<p>配置完成后我们可以通过命令 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">info</span></code> 查看 docker 详细信息</p>
</div>
<div class="section" id="id5">
<h3>常用操作<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 6%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>command</p></th>
<th class="head"><p>content</p></th>
<th class="head"><p>subobject</p></th>
<th class="head"><p>subobject content</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="4"><p>config</p></td>
<td rowspan="4"><p>Manage Docker configs</p></td>
<td><p>create</p></td>
<td><p>Create a configuration file from a file or STDIN as content</p></td>
</tr>
<tr class="row-odd"><td><p>inspect</p></td>
<td><p>Display detailed information on one or more configuration files</p></td>
</tr>
<tr class="row-even"><td><p>ls</p></td>
<td><p>List configs</p></td>
</tr>
<tr class="row-odd"><td><p>rm</p></td>
<td><p>Remove one or more configuration files</p></td>
</tr>
<tr class="row-even"><td rowspan="25"><p>container</p></td>
<td rowspan="25"><p>Manage container</p></td>
<td><p>attach</p></td>
<td><p>Attach local standard input, output, and error streams to a running container</p></td>
</tr>
<tr class="row-odd"><td><p>commit</p></td>
<td><p>Create a new image from a container’s changes</p></td>
</tr>
<tr class="row-even"><td><p>cp</p></td>
<td><p>Copy files/folders between a container and the local filesystem</p></td>
</tr>
<tr class="row-odd"><td><p>create</p></td>
<td><p>Create a new container</p></td>
</tr>
<tr class="row-even"><td><p>diff</p></td>
<td><p>Inspect changes to files or directories on a container’s filesystem</p></td>
</tr>
<tr class="row-odd"><td><p>exec</p></td>
<td><p>Run a command in a running container</p></td>
</tr>
<tr class="row-even"><td><p>export</p></td>
<td><p>Export a container’s filesystem as a tar archive</p></td>
</tr>
<tr class="row-odd"><td><p>inspect</p></td>
<td><p>Display detailed information on one or more containers</p></td>
</tr>
<tr class="row-even"><td><p>kill</p></td>
<td><p>Kill one or more running containers</p></td>
</tr>
<tr class="row-odd"><td><p>logs</p></td>
<td><p>Fetch the logs of a container</p></td>
</tr>
<tr class="row-even"><td><p>ls</p></td>
<td><p>List containers</p></td>
</tr>
<tr class="row-odd"><td><p>pause</p></td>
<td><p>Pause all processes whitin one or more containers</p></td>
</tr>
<tr class="row-even"><td><p>port</p></td>
<td><p>List port mappings or a specific mapping for the container</p></td>
</tr>
<tr class="row-odd"><td><p>prune</p></td>
<td><p>Remove all stopped containers</p></td>
</tr>
<tr class="row-even"><td><p>rename</p></td>
<td><p>Rename a container</p></td>
</tr>
<tr class="row-odd"><td><p>restart</p></td>
<td><p>Restart one or more containers</p></td>
</tr>
<tr class="row-even"><td><p>rm</p></td>
<td><p>Remove one or more container</p></td>
</tr>
<tr class="row-odd"><td><p>run</p></td>
<td><p>Run a command in a new container</p></td>
</tr>
<tr class="row-even"><td><p>start</p></td>
<td><p>Start one or more stopped containers</p></td>
</tr>
<tr class="row-odd"><td><p>stars</p></td>
<td><p>Display a live stream of container(s) resource usage statistics</p></td>
</tr>
<tr class="row-even"><td><p>stop</p></td>
<td><p>Stop one or more running containers</p></td>
</tr>
<tr class="row-odd"><td><p>top</p></td>
<td><p>Display the running processes of a containers</p></td>
</tr>
<tr class="row-even"><td><p>unpause</p></td>
<td><p>Unpause all processes within one or more containers</p></td>
</tr>
<tr class="row-odd"><td><p>update</p></td>
<td><p>Update configuration of one or more containers</p></td>
</tr>
<tr class="row-even"><td><p>wait</p></td>
<td><p>Block until one or more containers stop, then print their exit codes</p></td>
</tr>
<tr class="row-odd"><td rowspan="12"><p>image</p></td>
<td rowspan="12"><p>Manage images</p></td>
<td><p>build</p></td>
<td><p>Build an image from Dockerfile</p></td>
</tr>
<tr class="row-even"><td><p>history</p></td>
<td><p>Show the history of an image</p></td>
</tr>
<tr class="row-odd"><td><p>import</p></td>
<td><p>Import the containers from a tarball to create a filesystem image</p></td>
</tr>
<tr class="row-even"><td><p>inspect</p></td>
<td><p>Display detailed information on onw or more images</p></td>
</tr>
<tr class="row-odd"><td><p>load</p></td>
<td><p>Load an image from a tar archive or STDIN</p></td>
</tr>
<tr class="row-even"><td><p>ls</p></td>
<td><p>List images</p></td>
</tr>
<tr class="row-odd"><td><p>prune</p></td>
<td><p>Remove unused images</p></td>
</tr>
<tr class="row-even"><td><p>pull</p></td>
<td><p>Pull an image or a repository from a registry</p></td>
</tr>
<tr class="row-odd"><td><p>push</p></td>
<td><p>Push an image or a repository to a registry</p></td>
</tr>
<tr class="row-even"><td><p>rm</p></td>
<td><p>Remove one or more images</p></td>
</tr>
<tr class="row-odd"><td><p>save</p></td>
<td><p>Save one or more images to a tar archive (streamed to STDOUT by default)</p></td>
</tr>
<tr class="row-even"><td><p>tag</p></td>
<td><p>Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</p></td>
</tr>
<tr class="row-odd"><td rowspan="7"><p>network</p></td>
<td rowspan="7"><p>Manage networks</p></td>
<td><p>connect</p></td>
<td><p>Connect a container to a network</p></td>
</tr>
<tr class="row-even"><td><p>create</p></td>
<td><p>Create a network</p></td>
</tr>
<tr class="row-odd"><td><p>disconnect</p></td>
<td><p>Disconnect detailed information on one or more networks</p></td>
</tr>
<tr class="row-even"><td><p>inspect</p></td>
<td><p>Display detailed information on one or more networks</p></td>
</tr>
<tr class="row-odd"><td><p>ls</p></td>
<td><p>List networks</p></td>
</tr>
<tr class="row-even"><td><p>prune</p></td>
<td><p>Remove all unused networks</p></td>
</tr>
<tr class="row-odd"><td><p>rm</p></td>
<td><p>Remove one or more networks</p></td>
</tr>
<tr class="row-even"><td rowspan="7"><p>node</p></td>
<td rowspan="7"><p>Manage Swarm node</p></td>
<td><p>deamon</p></td>
<td><p>Demote one or more nodes from manager in the swarm</p></td>
</tr>
<tr class="row-odd"><td><p>inspect</p></td>
<td><p>Display detailed information on one or more nodes</p></td>
</tr>
<tr class="row-even"><td><p>ls</p></td>
<td><p>List nodes in the swarm</p></td>
</tr>
<tr class="row-odd"><td><p>promote</p></td>
<td><p>Promote one or more nodes to manager in the swarm</p></td>
</tr>
<tr class="row-even"><td><p>ps</p></td>
<td><p>List tasks running on one or more nodes, defaults to current node</p></td>
</tr>
<tr class="row-odd"><td><p>rm</p></td>
<td><p>Remove one or more nodes from the swarm</p></td>
</tr>
<tr class="row-even"><td><p>update</p></td>
<td><p>Update a node</p></td>
</tr>
<tr class="row-odd"><td rowspan="10"><p>plugin</p></td>
<td rowspan="10"><p>Manage plugins</p></td>
<td><p>create</p></td>
<td><p>Create a plugin from a rootfs and configuration. Plugin data directory must contain config.json and rootfs directory.</p></td>
</tr>
<tr class="row-even"><td><p>disable</p></td>
<td><p>Disable a plugin</p></td>
</tr>
<tr class="row-odd"><td><p>enable</p></td>
<td><p>Enable a plugin</p></td>
</tr>
<tr class="row-even"><td><p>inspect</p></td>
<td><p>Display detailed information on one or more plugins</p></td>
</tr>
<tr class="row-odd"><td><p>install</p></td>
<td><p>Install a plugin</p></td>
</tr>
<tr class="row-even"><td><p>ls</p></td>
<td><p>List plugins</p></td>
</tr>
<tr class="row-odd"><td><p>push</p></td>
<td><p>Push a plugin to a registry</p></td>
</tr>
<tr class="row-even"><td><p>rm</p></td>
<td><p>Remove one or more plugin</p></td>
</tr>
<tr class="row-odd"><td><p>set</p></td>
<td><p>Change settings for a plugin</p></td>
</tr>
<tr class="row-even"><td><p>upgrade</p></td>
<td><p>Upgrade an existing plugin</p></td>
</tr>
<tr class="row-odd"><td rowspan="4"><p>secret</p></td>
<td rowspan="4"><p>Manage Docker secrets</p></td>
<td><p>create</p></td>
<td><p>Create a secret from a file or STDIN as content</p></td>
</tr>
<tr class="row-even"><td><p>inspect</p></td>
<td><p>Display detailed information on onw or more secrets</p></td>
</tr>
<tr class="row-odd"><td><p>ls</p></td>
<td><p>List secrets</p></td>
</tr>
<tr class="row-even"><td><p>rm</p></td>
<td><p>Remove one or more secrets</p></td>
</tr>
<tr class="row-odd"><td rowspan="9"><p>service</p></td>
<td rowspan="9"><p>Manage service</p></td>
<td><p>create</p></td>
<td><p>Create a new service</p></td>
</tr>
<tr class="row-even"><td><p>inspect</p></td>
<td><p>Display detailed information on one or more services</p></td>
</tr>
<tr class="row-odd"><td><p>logs</p></td>
<td><p>Fetch the logs of a  service or task</p></td>
</tr>
<tr class="row-even"><td><p>ls</p></td>
<td><p>List services</p></td>
</tr>
<tr class="row-odd"><td><p>ps</p></td>
<td><p>List the tasks of one or more services</p></td>
</tr>
<tr class="row-even"><td><p>rm</p></td>
<td><p>Remove one or more services</p></td>
</tr>
<tr class="row-odd"><td><p>rollback</p></td>
<td><p>Revert changes to a service’s configuration</p></td>
</tr>
<tr class="row-even"><td><p>scale</p></td>
<td><p>Scale one or multiple replicated services</p></td>
</tr>
<tr class="row-odd"><td><p>update</p></td>
<td><p>Update a service</p></td>
</tr>
<tr class="row-even"><td rowspan="9"><p>stack</p></td>
<td rowspan="9"><p>Manage Docker stacks</p></td>
<td><p>create</p></td>
<td><p>Create a new service</p></td>
</tr>
<tr class="row-odd"><td><p>inspect</p></td>
<td><p>Display detailed information on one or more services</p></td>
</tr>
<tr class="row-even"><td><p>logs</p></td>
<td><p>Fetch the logs of a service or task</p></td>
</tr>
<tr class="row-odd"><td><p>ls</p></td>
<td><p>List services</p></td>
</tr>
<tr class="row-even"><td><p>ps</p></td>
<td><p>List the tasks of one or more services</p></td>
</tr>
<tr class="row-odd"><td><p>rm</p></td>
<td><p>Remove one or more services</p></td>
</tr>
<tr class="row-even"><td><p>rollback</p></td>
<td><p>Revert changes to a service’s configuration</p></td>
</tr>
<tr class="row-odd"><td><p>scale</p></td>
<td><p>Scale one or multiple replicated services</p></td>
</tr>
<tr class="row-even"><td><p>update</p></td>
<td><p>Update a services</p></td>
</tr>
<tr class="row-odd"><td rowspan="8"><p>swarm</p></td>
<td rowspan="8"><p>Manage Swarm</p></td>
<td><p>ca</p></td>
<td><p>Display and rotate the root CA</p></td>
</tr>
<tr class="row-even"><td><p>init</p></td>
<td><p>Initialize a swarm</p></td>
</tr>
<tr class="row-odd"><td><p>join</p></td>
<td><p>Join a swarm as a node and/or manager</p></td>
</tr>
<tr class="row-even"><td><p>join-token</p></td>
<td><p>Manager join tokens</p></td>
</tr>
<tr class="row-odd"><td><p>leave</p></td>
<td><p>Leave the swarm</p></td>
</tr>
<tr class="row-even"><td><p>unlock</p></td>
<td><p>Unlock swarm</p></td>
</tr>
<tr class="row-odd"><td><p>unlock-key</p></td>
<td><p>Manage the unlock key</p></td>
</tr>
<tr class="row-even"><td><p>update</p></td>
<td><p>Update the swarm</p></td>
</tr>
<tr class="row-odd"><td rowspan="4"><p>system</p></td>
<td rowspan="4"><p>Manage Docker</p></td>
<td><p>df</p></td>
<td><p>Show docker disk usage</p></td>
</tr>
<tr class="row-even"><td><p>events</p></td>
<td><p>Get real time events from the server</p></td>
</tr>
<tr class="row-odd"><td><p>info</p></td>
<td><p>Display system-wide information</p></td>
</tr>
<tr class="row-even"><td><p>prune</p></td>
<td><p>Remove unused data</p></td>
</tr>
<tr class="row-odd"><td rowspan="6"><p>trust</p></td>
<td rowspan="6"><p>Manage trust on Docker images (experimental)</p></td>
<td><p>key</p></td>
<td><p>Manage keys for signing Docker images (experimental)</p></td>
</tr>
<tr class="row-even"><td><p>signer</p></td>
<td><p>Manage entities who can sign Docker images (experimental)</p></td>
</tr>
<tr class="row-odd"><td><p>inspect</p></td>
<td><p>Return low-level information about keys and signatures</p></td>
</tr>
<tr class="row-even"><td><p>revoke</p></td>
<td><p>Remove trust for an image</p></td>
</tr>
<tr class="row-odd"><td><p>sign</p></td>
<td><p>Sign an image</p></td>
</tr>
<tr class="row-even"><td><p>view</p></td>
<td><p>Display detailed information about keys and signatures</p></td>
</tr>
<tr class="row-odd"><td rowspan="5"><p>volume</p></td>
<td rowspan="5"><p>Manage volumes</p></td>
<td><p>create</p></td>
<td><p>Create a volume</p></td>
</tr>
<tr class="row-even"><td><p>inspect</p></td>
<td><p>Display detailed information on one or more volumes</p></td>
</tr>
<tr class="row-odd"><td><p>ls</p></td>
<td><p>List volumes</p></td>
</tr>
<tr class="row-even"><td><p>prune</p></td>
<td><p>Remove all unused volumes</p></td>
</tr>
<tr class="row-odd"><td><p>rm</p></td>
<td><p>Remove one or more volumes</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id6">
<h3>状态转换<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<img alt="../../_images/docker_event_stats.jpg" src="../../_images/docker_event_stats.jpg" />
</div>
</div>
<div class="section" id="id7">
<h2>网络模型<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>当你开始大规模使用 Docker 时，你会发现需要了解很多关于网络的知识。Docker 容器需要运行在一台宿主机上，可以是一台物理机（on-premise 数据中心的裸金属服务器），也可以是 on-prem 或云上的一台虚拟机。</p>
<div class="section" id="id8">
<h3>简单的 Docker 架构<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>宿主机和容器的关系是 <code class="docutils literal notranslate"><span class="pre">1:N</span></code> ，这意味着一台宿主机上可以运行多个容器。例如，从 Facebook 的报告来看，取决于机器的能力，每台宿主机上平均可以运行 10 到 40 个容器。另一个数据是：在 Mesosphere，我们发现，在裸金属服务器上的各种负载测试中，每台宿主机上不超过 250 个容器是可能的。</p>
<p>无论你是在单主机上进行部署，还是在集群上部署，你总得和网络打交道：</p>
<ul class="simple">
<li><p>对于大多数单主机部署来说，问题归结于是使用共享卷进行数据交换，还是使用网络（基于 HTTP 或者其他的）进行数据交换。尽管 Docker 数据卷很容易使用，但也引入了紧耦合，这意味着很难将单主机部署转换为多主机部署。自然地，共享卷的优势是速度。</p></li>
<li><p>在多主机部署中，你需要考虑两个方面：单主机上的容器之间如何通信和多主机之间的通信路径是怎样的。性能考量和安全方面都有可能影响你的设计决定。多主机部署通常是很有必要的，原因是单主机的能力有限，也可能是因为需要部署分布式系统，例如 Apache Spark、HDFS 和 Cassandra。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>分布式系统的数据本地化（Distributed Systems and Data Locality）</p>
<p>使用分布式系统（计算或存储）的基本想法是想从并行处理中获利，通常伴随着数据本地化。数据本地化，我指的是将代码转移到数据所在地的原则，而不是传统的、其他的方式。考虑以下的场景：如果你的数据集是 TB 级的，而代码是 MB 级的，那么在集群中移动代码此传输 TB 级数据更高效。除了可以并行处理数据之外，分布式系统还可以提供容错性，因为系统中的一部分可以相对独立地工作。</p>
</div>
<p>简单的说，Docker 网络是原生的容器 SDN 解决方案。总而言之，Docker 网络有四种模式：桥接模式，主机模式，容器模式和无网络模式。我们会详细地讨论主机上的各种网络模式。</p>
<img alt="../../_images/four-network-container-archetypes.png" src="../../_images/four-network-container-archetypes.png" />
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
94bb253e0ddc        bridge              bridge              <span class="nb">local</span>
59d9038bfac5        host                host                <span class="nb">local</span>
920274f49a70        none                null                <span class="nb">local</span>
</pre></div>
</div>
</div>
<div class="section" id="bridge">
<h3>bridge 模式网络<a class="headerlink" href="#bridge" title="Permalink to this headline">¶</a></h3>
<p>在该模式中，docker 守护进程创建了一个虚拟以太网桥 <code class="docutils literal notranslate"><span class="pre">docker0</span></code> ，附加在其上的任何网卡之间都能自动转发数据包。默认情况下，守护进程会创建一对对等接口，将其中一个接口设置为容器的 eth0 接口，另一个接口放置在宿主机的命名空间中，从而将宿主机上的所有容器都链接到这个内部网络上。同时，守护进程还会从网桥的似有地址空间中分配一个IP地址和子网给该容器。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker container run --name<span class="o">=</span>web01 --detach --publish-all --net<span class="o">=</span>bridge nginx:1.14-alpine
$ docker container ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
7f056ef642b7        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   <span class="m">6</span> seconds ago       Up <span class="m">4</span> seconds        <span class="m">0</span>.0.0.0:32768-&gt;80/tcp   web01
$ docker container inspect web01
...
<span class="s2">&quot;NetworkSettings&quot;</span>: <span class="o">{</span>
    <span class="s2">&quot;Bridge&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;SandboxID&quot;</span>: <span class="s2">&quot;56cb1f03f8eda8c1ce73a764eb36794cd87dbf3cae399d2220b623b1f711678a&quot;</span>,
    <span class="s2">&quot;HairpinMode&quot;</span>: false,
    <span class="s2">&quot;LinkLocalIPv6Address&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;LinkLocalIPv6PrefixLen&quot;</span>: <span class="m">0</span>,
    <span class="s2">&quot;Ports&quot;</span>: <span class="o">{</span>
        <span class="s2">&quot;80/tcp&quot;</span>: <span class="o">[</span>
            <span class="o">{</span>
                <span class="s2">&quot;HostIp&quot;</span>: <span class="s2">&quot;0.0.0.0&quot;</span>,
                <span class="s2">&quot;HostPort&quot;</span>: <span class="s2">&quot;32768&quot;</span>
            <span class="o">}</span>
        <span class="o">]</span>
    <span class="o">}</span>,
    <span class="s2">&quot;SandboxKey&quot;</span>: <span class="s2">&quot;/var/run/docker/netns/56cb1f03f8ed&quot;</span>,
    <span class="s2">&quot;SecondaryIPAddresses&quot;</span>: null,
    <span class="s2">&quot;SecondaryIPv6Addresses&quot;</span>: null,
    <span class="s2">&quot;EndpointID&quot;</span>: <span class="s2">&quot;11ede3c1709ded6a68dd5c4a4607feb5eec780534a8882580b9bc30c79c14b7a&quot;</span>,
    <span class="s2">&quot;Gateway&quot;</span>: <span class="s2">&quot;172.17.0.1&quot;</span>,
    <span class="s2">&quot;GlobalIPv6Address&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="m">0</span>,
    <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;172.17.0.2&quot;</span>,
    <span class="s2">&quot;IPPrefixLen&quot;</span>: <span class="m">16</span>,
    <span class="s2">&quot;IPv6Gateway&quot;</span>: <span class="s2">&quot;&quot;</span>,
    <span class="s2">&quot;MacAddress&quot;</span>: <span class="s2">&quot;02:42:ac:11:00:02&quot;</span>,
    <span class="s2">&quot;Networks&quot;</span>: <span class="o">{</span>
        <span class="s2">&quot;bridge&quot;</span>: <span class="o">{</span>
            <span class="s2">&quot;IPAMConfig&quot;</span>: null,
            <span class="s2">&quot;Links&quot;</span>: null,
            <span class="s2">&quot;Aliases&quot;</span>: null,
            <span class="s2">&quot;NetworkID&quot;</span>: <span class="s2">&quot;94bb253e0ddcd0f2f7b0037bc51c537d2bdcd5d5a156963fbf1c611c37ae807d&quot;</span>,
            <span class="s2">&quot;EndpointID&quot;</span>: <span class="s2">&quot;11ede3c1709ded6a68dd5c4a4607feb5eec780534a8882580b9bc30c79c14b7a&quot;</span>,
            <span class="s2">&quot;Gateway&quot;</span>: <span class="s2">&quot;172.17.0.1&quot;</span>,
            <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;172.17.0.2&quot;</span>,
            <span class="s2">&quot;IPPrefixLen&quot;</span>: <span class="m">16</span>,
            <span class="s2">&quot;IPv6Gateway&quot;</span>: <span class="s2">&quot;&quot;</span>,
            <span class="s2">&quot;GlobalIPv6Address&quot;</span>: <span class="s2">&quot;&quot;</span>,
            <span class="s2">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="m">0</span>,
            <span class="s2">&quot;MacAddress&quot;</span>: <span class="s2">&quot;02:42:ac:11:00:02&quot;</span>,
            <span class="s2">&quot;DriverOpts&quot;</span>: null
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
...
</pre></div>
</div>
<p>查看 bridge 网桥与容器的接口</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ yum -y install bridge-utils
$ brctl show
bridge name bridge id               STP enabled     interfaces
docker0             <span class="m">8000</span>.02428b0967f8       no              veth20f8faa
</pre></div>
</div>
<p>因为 bridge 模式是 Docker 的默认设置，所以你也可以使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--detach</span> <span class="pre">--publish-all</span> <span class="pre">--name=web01</span> <span class="pre">nginx:1.14-alpine</span></code> 。如果你没有使用 –publish-all（发布该容器暴露的所有端口）或者 –publish host_port:container_port（发布某个特定的端口），IP 数据包就不能从宿主机之外路由到容器中。</p>
<img alt="../../_images/container_network_mode_bridge.png" src="../../_images/container_network_mode_bridge.png" />
</div>
<div class="section" id="host">
<h3>host 模式<a class="headerlink" href="#host" title="Permalink to this headline">¶</a></h3>
<p>该模式将禁用 Docker 容器的网络隔离。因为容器共享了宿主机的网络命名空间，直接暴露再公共网络之中。因此，你需要通过端口映射（port mapping）来进行协调。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker container run --detach --name<span class="o">=</span>web01 --publish-all --net<span class="o">=</span>host nginx:1.14-alpine
882db350e02b9922bd911ce9d1b08cfc085cc7baf1dee2a75fbfeae1fae12cfd
$ ip addr <span class="p">|</span> grep -A <span class="m">2</span> eth0:
<span class="m">2</span>: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP group default qlen <span class="m">1000</span>
link/ether d0:0d:b5:97:40:9f brd ff:ff:ff:ff:ff:ff
inet <span class="m">172</span>.19.135.14/24 brd <span class="m">172</span>.19.135.255 scope global dynamic eth0
$ docker container ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
c5a4c0105f22        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   About a minute ago   Up About a minute                       web01
</pre></div>
</div>
<p>我们进入容器内部查看网卡信息</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker container exec --interactive --tty web01 /bin/sh</span>
/ <span class="c1"># ip a</span>
<span class="m">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN qlen <span class="m">1</span>
    link/loopback <span class="m">00</span>:00:00:00:00:00 brd <span class="m">00</span>:00:00:00:00:00
    inet <span class="m">127</span>.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
    valid_lft forever preferred_lft forever
<span class="m">2</span>: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP qlen <span class="m">1000</span>
    link/ether d0:0d:b5:97:40:9f brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.19.135.14/24 brd <span class="m">172</span>.19.135.255 scope global dynamic eth0
    valid_lft 314753218sec preferred_lft 314753218sec
    inet6 fe80::d20d:b5ff:fe97:409f/64 scope link
    valid_lft forever preferred_lft forever
<span class="m">3</span>: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span class="m">1500</span> qdisc noqueue state DOWN
    link/ether <span class="m">02</span>:42:8b:09:67:f8 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.17.0.1/16 scope global docker0
    valid_lft forever preferred_lft forever
    inet6 fe80::42:8bff:fe09:67f8/64 scope link
    valid_lft forever preferred_lft forever
/ <span class="c1"># exit</span>
</pre></div>
</div>
<p>我们可以从上例中看到：容器和宿主机具有相同的IP地址 <code class="docutils literal notranslate"><span class="pre">172.19.135.14</span></code></p>
<p>在下图中我们可以看到：当使用 host 模式网络时，容器实际上继承了宿主机的IP地址。该模式比 bridge 模块更快（因为没有路由开销），但是它将容器直接暴露在公共网络中，是有安全隐患的。</p>
<img alt="../../_images/Docker_network_mode_host.png" src="../../_images/Docker_network_mode_host.png" />
</div>
<div class="section" id="container">
<h3>container 模式网络<a class="headerlink" href="#container" title="Permalink to this headline">¶</a></h3>
<p>该模式会重用另一个容器的网络名称空间。通常来说，当你想要自定网络栈时，该模式时很有用的。实际上，该模式也是 Kubernetes 使用的网络模式。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker container run --detach --publish-all --net=bridge --name=web01 nginx:1.14-alpine</span>
07d43ffe5f341cb10a46c3be9c71a05ffa5b5004aedb38a6cc975705855b8dd9
<span class="c1"># docker ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
07d43ffe5f34        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   <span class="m">7</span> seconds ago       Up <span class="m">6</span> seconds        <span class="m">0</span>.0.0.0:32769-&gt;80/tcp   web01
<span class="c1"># docker exec --tty --interactive web01 ip addr</span>
<span class="m">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN qlen <span class="m">1</span>
    link/loopback <span class="m">00</span>:00:00:00:00:00 brd <span class="m">00</span>:00:00:00:00:00
    inet <span class="m">127</span>.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
<span class="m">6</span>: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu <span class="m">1500</span> qdisc noqueue state UP
    link/ether <span class="m">02</span>:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.17.0.2/16 scope global eth0
    valid_lft forever preferred_lft forever
<span class="c1"># docker run --interactive --tty --net=container:web01 ubuntu:14.04 ip addr</span>
<span class="m">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1</span>
    link/loopback <span class="m">00</span>:00:00:00:00:00 brd <span class="m">00</span>:00:00:00:00:00
    inet <span class="m">127</span>.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
<span class="m">6</span>: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default
    link/ether <span class="m">02</span>:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet <span class="m">172</span>.17.0.2/16 scope global eth0
    valid_lft forever preferred_lft forever
</pre></div>
</div>
<p>结果显示：第二个容器使用 <code class="docutils literal notranslate"><span class="pre">--net=container</span></code> 参数，因此和第一个容器 <code class="docutils literal notranslate"><span class="pre">web01</span></code> 具有相同的ip地址 <code class="docutils literal notranslate"><span class="pre">172.17.0.2</span></code></p>
</div>
<div class="section" id="none">
<h3>none 模式网络<a class="headerlink" href="#none" title="Permalink to this headline">¶</a></h3>
<p>该模式将容器放置在它自己的网络中，但是并不进行任何配置。实际上，该模式关闭了容器的网络功能，在以上两种情况下时有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）；你希望自定义网络。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># docker container run --detach --publish-all --net=none nginx:1.14-alpine</span>
90e19ccb6938b12c366022411a93f25ecb05a7f6b49dd640bb5a0703068076ab
<span class="c1"># docker ps</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
90e19ccb6938        nginx:1.14-alpine   <span class="s2">&quot;nginx -g &#39;daemon ...&quot;</span>   <span class="m">12</span> seconds ago      Up <span class="m">10</span> seconds                           gracious_bartik
<span class="c1"># docker container inspect gracious_bartik | grep IPAddress</span>
        <span class="s2">&quot;SecondaryIPAddresses&quot;</span>: null,
        <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;&quot;</span>,
                <span class="s2">&quot;IPAddress&quot;</span>: <span class="s2">&quot;&quot;</span>,
</pre></div>
</div>
<p>在上面的例子中可以看到，恰如我们所料，网络没有任何配置。</p>
</div>
<div class="section" id="id9">
<h3>其他网络话题<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>分配IP地址</p>
<blockquote>
<div><p>频繁大量的创建和销毁容器时，手动分配IP地址是不能接受的。bridge 模式可以在一定程度上解决这个问题。为了防止本地网络上的 ARP 冲突，Docker Daemon 会根据分配的IP地址生成一个随机的 MAC 地址。</p>
</div></blockquote>
</li>
<li><p>分配端口</p>
<blockquote>
<div><p>你会发现有两大阵营：固定端口分配（fixed-port-allocation）和动态端口分配（dynamically-port-allocation）。每个服务或者应用可以有各自的分配方法，也可以是作为全局的策略，但是你必须做出自己的判断和决定。请记住，bridge 模式中，Docker 会自动分配 UDP 或 TCP 端口，并使其可路由。</p>
</div></blockquote>
</li>
<li><p>网络安全</p>
<blockquote>
<div><p>Docker 可以开启容器间通信（意味着默认配置 <code class="docutils literal notranslate"><span class="pre">--icc=true</span></code> ），也就是说，宿主机上的所有容器可以不接受任何限制地相互通讯，这可能导致拒绝服务攻击。进一步地，Docker 可以通过 <code class="docutils literal notranslate"><span class="pre">--ip_forward</span></code> 和 <code class="docutils literal notranslate"><span class="pre">--iptables</span></code> 两个选项控制容器间、容器和外部世界的通信。你应该了解这些选项的默认值，并让网络组根据公司策略设置 Docker 进程。</p>
<p>另一个网络安全方面是线上加密（on-the-wire encryption），通常是指 RFC 5246 中定义的 TLS/SSL。</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id10">
<h3>跨主机网络<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>在微服务架构中，多个服务是通过服务注册中心进行管理的，服务需要将自己的IP地址和端口发送给注册中心，这样该服务才能被其他服务感知并调用。但是当服务在 docker 容器内运行时，服务获取到的自身IP是宿主机分配的内部IP（默认情况下会在 172.17.0.0/16 子网下），如 172.17.0.1 这个地址只能在宿主机内部使用（通过 docker0 网桥转发），其他的主机是无法 ping 通地。我们就以服务注册的场景讨论 docker 容器跨主机通信方案。</p>
<ul>
<li><p>端口映射</p>
<blockquote>
<div><p>启动容器时通过 -p 参数将容器内服务监听的端口映射到主机端口中。例如容器运行的 web 服务监听 8080 端口，那么当指定 -p 8080:80 时，外部就可以通过访问宿主机的 80 端口访问到这个 web 服务了。</p>
<p>这种方式有一个很大的缺点：服务器端口是一种稀缺资源，一台主机往往会运行多个容器，它们之间很可能会出现端口冲突的情况，而且就服务注册这个场景而言，容器内的 web 服务是无法主动得到宿主机的ip地址的，因此需要我们在启动容器时通过 Dockerfile 将宿主机IP通过环境变量注入到容器中，然后配置 web 项目使用我们指定的 IP 来注册自身。这种方式显然无法应用于大规模集群部署。</p>
</div></blockquote>
</li>
<li><p>不进行网络隔离，直接使用宿主机网络配置</p>
<blockquote>
<div><p>通过 –net=host 参数可以指定使用该模式。在这种模式下，容器的网络环境并没有通过 Linux 内核的 Network Namespace 进行隔离，在容器内可以自由修改宿主机的网络参数，因此是不安全的，但优点是网络性能损失可以忽略不计。对于我们的场景来说，微服务能够想直接部署一样征程获取到主机IP。</p>
</div></blockquote>
</li>
<li><p>组件 overlay 网络</p>
<blockquote>
<div><p>Overlay 网络其实就是隧道技术，即将一种网络协议包装在另一种协议中传输的技术。Docker 常见的 overlay 网络实现有 flannel，swarm overlay，Open vSwitch 等。它们的工作流程基本都是一样的：通过某种方式保证所有 docker 容器都有全局唯一的 IP，然后把 docker 容器的ip和其他所在宿主机ip的对应关系存放到第三方存储服务中（如 etcd，consul），之后通过在宿主机上修改路由表、创建虚拟网卡的方式，将数据包转发到目标容器所在的宿主机上，最后再由目标宿主机的 docekr0 网桥转发给容器。对 flannel 来说，它的工作原理如下：</p>
<img alt="../../_images/flannel_work.png" src="../../_images/flannel_work.png" />
<p>10.56.78.1 和 10.56.78.2 是局域网内的两台物理机，它们各运行着container01和container02。当container01要访问container02时：</p>
<ol class="arabic simple">
<li><p>数据包首先到达 docker0，由于 flannel 修改了路由表，docker0 会将其转发给 flannel0</p></li>
<li><p>flannel 的守护进程 flanneld 会持续监听flannel 转出的数据包，它首先会到 etcd 中查询 container01 所在的宿主机的 IP(10.56.78.1)，然后将原数据包进行封装（可以使用 UDP 或 vxlan 封装），把目的的IP地址改为对方宿主机IP并交由 eth0</p></li>
<li><p>etcd 将新数据包通过网络发到 10.56.78.2</p></li>
<li><p>10.56.78.2 的 eth0 收到数据包后转发给 flannel0，由守护进程 flanneld 进行解包，取出原数据包，得到容器IP地址 172.17.0.2，然后转发给 docker0</p></li>
<li><p>docker0 将数据包转发至容器进程对应端口</p></li>
</ol>
<p>至此 container01 就实现了跨主机访问 container02。</p>
<p>oberlay 网络的性能损耗取决于其实现方式，经测试，flannel(vxlan模式)，swarm overlay 实现的损耗几乎与端口映射持平，但是 docker 1.12 版本新加入的 swarm overlay 实现性能损耗高达 60%（swarm overlay 代码实现质量不高）。因此，在生产环境中不建议使用 swarm overlay 方案。</p>
</div></blockquote>
</li>
<li><p>Calico 和 Weave</p>
<blockquote>
<div><p>这两种实现的方式跟 overlay 不太一样，它会把每台宿主机都当成一个路由器使用，数据包在各个主机之间流动最终被投递到目标主机。为了让主机支持路由功能，它们会向路由表中写入大量记录，因此如果集群中的节点太多，路由表记录数过高（超过1万）时性能会出现问题。</p>
<p>虽然实现原理一样，但它们的性能区别还是很大的，Calico 因为使用的是内核特性，能做到在内核态完成路由，因此性能于原生网络非常接近（90%以上），而 Weave 则是在用户态转发数据包，性能比较差，损耗高达 70% 以上。</p>
</div></blockquote>
</li>
<li><p>总结</p>
<blockquote>
<div><p>overlay 方案和 Calico，Weave 由于可以实现容器IP的直接通信，因此在服务注册的场景下都可以正常运行，到那时需要付出一定的性能代价。而端口映射方式则需要强行配置我们的应用使用指定IP，灵活性极差，只适用于小规模的集群部署。而 host 模式则是通过牺牲隔离性来换取最大化网络性能。在实际应用中我们应该根据业务特点来选择最适合的网络方案。</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="id11">
<h2>网络基础使用<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id12">
<h3>与 bridge 相关的参数<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>可以为 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span></code> 命令使用</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">--hostname</span> <span class="pre">HOSTNAME</span></code> 选项为容器指定主机名，例如</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker container --rm --net<span class="o">=</span>bridge --hostname<span class="o">=</span>bbox.renkeju.com busybox:latest nslookup bbox.renkeju.com
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">--dns</span> <span class="pre">DNS_SERVER_IP</span></code> 选项能够为容器指定所使用的 dns 服务器地址，例如</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker container run --dns <span class="m">8</span>.8.8.8 busybox:latest nslookup docker.com
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">--add-host</span> <span class="pre">HOSTNAME:IP</span></code> 选项能够为容器指定本地主机名解析项，例如</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker container run --rm --dns <span class="m">8</span>.8.8.8 -add-host <span class="s2">&quot;docker.com:172.16.0.100&quot;</span> busybox:latest nslookup docker.com
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id13">
<h3>打开入站通讯<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">--publish</span></code> 选项使用格式</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">--publish</span> <span class="pre">&lt;ContainerPort&gt;</span></code></p>
<blockquote>
<div><p>将制定的容器端口映射至主机所有地址的一个动态端口</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">--publish</span> <span class="pre">&lt;HostPort&gt;:&lt;ContainerPort&gt;</span></code></p>
<blockquote>
<div><p>将容器端口 &lt;ContainerPort&gt; 映射至指定的主机端口 &lt;hostPort&gt;</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">--publish</span> <span class="pre">&lt;ip&gt;::&lt;ContainerPort&gt;</span></code></p>
<blockquote>
<div><p>将指定的容器端口 &lt;ContainerPort&gt; 映射至主机指定 &lt;ip&gt; 的动态端口</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">--publish</span> <span class="pre">&lt;ip&gt;:&lt;hostPort&gt;:&lt;containerPort&gt;</span></code></p>
<blockquote>
<div><p>将指定的容器端口 &lt;containerPort&gt; 映射至主机指定 &lt;ip&gt; 的端口 &lt;hostPort&gt;</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>“动态端口” 指的是随机端口，具体的映射结果可以使用 docker port 命令查看</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker container port wordpresss_wordpress_1
<span class="m">80</span>/tcp -&gt; <span class="m">0</span>.0.0.0:80
</pre></div>
</div>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">--publish-all</span></code> 选项将容器的所有计划要暴露端口全部都映射至主机端口</p></li>
<li><p>计划要暴露的端口使用 <code class="docutils literal notranslate"><span class="pre">--expose</span></code> 选项指定</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker container run --detach --publish-all --expose <span class="m">3333</span> --expose <span class="m">2222</span> --name<span class="o">=</span>web01 busybox:latest /bin/httpd -p <span class="m">2222</span> -f
</pre></div>
</div>
<ul>
<li><p>查看映射结果</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker container port web01
<span class="m">2222</span>/tcp -&gt; <span class="m">0</span>.0.0.0:32772
<span class="m">3333</span>/tcp -&gt; <span class="m">0</span>.0.0.0:32771
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>如果不想使用默认的 docker0 桥接口，或者需要修改此桥接口的网络属性，可以通过 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">daemon</span></code> 命令使用 <code class="docutils literal notranslate"><span class="pre">-b</span></code> <code class="docutils literal notranslate"><span class="pre">--bip</span></code> <code class="docutils literal notranslate"><span class="pre">--fixed-cidr</span></code> <code class="docutils literal notranslate"><span class="pre">--default-gateway</span></code> <code class="docutils literal notranslate"><span class="pre">--dns</span></code> <code class="docutils literal notranslate"><span class="pre">--mtu</span></code> 等选项进行设定。也可以通过修改 <code class="docutils literal notranslate"><span class="pre">/etc/docker/daemon.json</span></code> 配置文件设定。</p></li>
<li><p>docker 守护进程的 C/S，默认仅监听 Unix Socket 格式的地址 <code class="docutils literal notranslate"><span class="pre">/var/run/docker.sock</span></code></p>
<blockquote>
<div><p>如果使用 TCP 套接字，需要修改 <code class="docutils literal notranslate"><span class="pre">/etc/docker/daemon.json</span></code> 文件。
使用 <code class="docutils literal notranslate"><span class="pre">-H|--host</span></code> 选项可远程链接开启 TCP 套接字文件的 docker server。</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="id14">
<h2>存储卷<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Docker 镜像由多个只读层叠加而成，启动容器时，Docker 会加载只读镜像层并在镜像栈顶部添加一个读写层</p></li>
<li><p>如果运行中的容器修改了现有的一个已存在的文件，那该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏，此即“写时复制（COW）”机制。</p></li>
</ul>
<img alt="../../_images/Copy_on_write.png" src="../../_images/Copy_on_write.png" />
<p>COW 这种机制我们增删改查等一类的操作必然会降低文件系统的效率，那带来的是那些对I/O要求较高的应用（例如：RedisMySQL）实现持久化存储的时候，这样的存储系统性能会大打折扣。</p>
<p>如果要绕过这种机制，我们可以通过存储卷来实现。特全级的名称空间当中，我们也可以理解为宿主机当中找一个本地文件系统，创建一个本地目录，把这个目录与容器内部的文件系统的某一目录创建绑定关系。</p>
<div class="section" id="id15">
<h3>什么是卷<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>关闭并重启容器，其数据不受影响；但删除 Docker 容器，则其更改将会全部丢失</p></li>
<li><p>存在的问题</p>
<blockquote>
<div><ul class="simple">
<li><p>存储与联合文件系统中，不易被宿主机访问</p></li>
<li><p>容器间数据共享不便</p></li>
<li><p>删除容器其数据会丢失</p></li>
</ul>
</div></blockquote>
</li>
<li><p>解决方案 “卷”</p>
<blockquote>
<div><p>“卷” 是容器上的一个或多个“目录”，此类目录可以绕过联合文件系统，与宿主机上的某目录“绑定（关联）”</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="vs">
<h3>有状态服务 VS 无状态服务<a class="headerlink" href="#vs" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>无状态服务（Stateless Service）</p>
<blockquote>
<div><p>是指该服务运行的实例不会在本地存储需要持久化的数据，并且多个实例对于同一个请求响应的结果是完全一致的。这类服务在 k8s 平台创建后，借助 k8s 内部的负载均衡，当访问该服务的请求到达服务一端后，负载均衡会随机找到一个实例来完整该请求的响应（目前为轮询）。这类服务的实例可能会应为一些原因停止或者重新创建（如扩容时），这时，这些停止的实例里的所有信息（除日志和监控数据外）都将丢失（重启容器就会丢失）。因此如果您的容器实例里需要保留重要的信息，并希望随时可以备份以便与以后可以恢复的话，那么建议您创建有状态服务。</p>
</div></blockquote>
</li>
<li><p>有状态服务（Stateful Service）</p>
<blockquote>
<div><p>是指该服务的实例可以将一部分数据随时进行备份，并且在创建一个新的有状态服务时，可以通过备份恢复这些数据，以达到数据持久化的目的。有状态服务只能有一个实例，因此不支持“自动服务容量调节”。一般来说，数据库服务或者需要在本地文件系统存储配置文件或其他永久数据的应用程序可以创建使用有状态服务。想要创建有状态服务，必须满足几个前提：</p>
<p>待创建的服务镜像（image）的 Dockerfile 中必须定义了存储卷（Volume），因为只有存储所在目录里的数据可以被备份。
创建服务时，必须指定给该存储卷分配的磁盘空间大小。
如果创建服务的同时需要从之前的一个备份里恢复数据，那么还要指明该存储卷用哪个备份恢复。</p>
</div></blockquote>
</li>
<li><p>无状态服务和有状态服务主要有以下几点区别</p>
<blockquote>
<div><ol class="arabic">
<li><p>实例数量</p>
<blockquote>
<div><p>无状态服务可以有一个或多个实例，因此支持两种服务容量调节模式；有状态服务智能有一个实例，不允许创建多个实例，因此也不支持服务容量调节模式。</p>
</div></blockquote>
</li>
<li><p>存储卷</p>
<blockquote>
<div><p>无状态服务可以有存储卷，也可以没有，即使有也无法备份存储卷里面的数据；有状态服务必须有存储卷，并且在创建服务时，必须指定给该存储卷分配的磁盘的空间大小。</p>
</div></blockquote>
</li>
<li><p>数据存储</p>
<blockquote>
<div><p>无状态服务在运行过程中的所有数据（除日志和监控数据）都存在容器实例的文件系统中，如果实例停止或删除，则这些数据都将丢失，无法找回；而对于有状态服务，凡是已经挂载了存储卷的目录下的文件内容都可以随时进行备份，备份的数据可以下载，也可以用于恢复新的服务。但对于没有挂载卷的目录下的数据，仍然时无法备份和保存的，如果实例停止或者删除，这些非挂载卷里的文件内容同样会丢失。</p>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="volume">
<h3>volume 的几种形态<a class="headerlink" href="#volume" title="Permalink to this headline">¶</a></h3>
<p>有状态容器有数据持久化需求。Docker 采用 AFUS 分层文件系统时，文件系统的改动都是发生在最上面的容器层。在容器的声明周期内，他是持续的，包括容器在被停止后。但是，当容器被删除后，该数据层也随之被删除了。因此，Docker 采用 volume（卷）的形式来向容器提供持久化存储。Docker volume 有如下几种状态。</p>
<ol class="arabic">
<li><p>无 —— 不使用 Docker volume</p>
<blockquote>
<div><p>默认情况下，容器不使用任何 volume，此时，容器的数据被保存在容器之内，它只在容器的生命周期内存在，会随着容器的被删除而删除。当然，也可以使用 docker commit 命令将它持久化为一个新的镜像。</p>
</div></blockquote>
</li>
<li><p>Data volume（数据卷）</p>
<blockquote>
<div><p>一个 data volume 是容器中绕过 Union 文件系统的一个特定的目录。它被设计用来保存数据，而不管容器的生命周期。因此，当你删除一个容器时，Docker 肯定不会自动地删除一个 volume。有如下几种方式来使用 data volume：</p>
<ul>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">-v</span> <span class="pre">local_file:container_file</span></code> 形式</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker container run --detach --publish-all --name kvstor --volume ~/Documents/redis/redis.conf:/usr/local/etc/redis/redis.conf redis:4.0-alpine
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container inspect kvstor
...
&quot;Mounts&quot;: [
    {
        &quot;Type&quot;: &quot;bind&quot;,
        &quot;Source&quot;: &quot;/Users/renkeju/Documents/docker-compose/redis/redis.conf&quot;,
        &quot;Destination&quot;: &quot;/usr/local/etc/redis/redis.conf&quot;,
        &quot;Mode&quot;: &quot;&quot;,
        &quot;RW&quot;: true,
        &quot;Propagation&quot;: &quot;rprivate&quot;
    },
...
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">-v</span> <span class="pre">container_dir</span></code> 形式 Docker-managed volume</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker container run --detach --name web01 --volume /webapp nginx
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;Mounts&quot;: [
    {
        &quot;Type&quot;: &quot;volume&quot;,
        &quot;Name&quot;: &quot;fb00ff0ceb59cc1e1f1cb995ccddf071660146142f64b2a6e81037b37454c614&quot;,
        &quot;Source&quot;: &quot;/var/lib/docker/volumes/fb00ff0ceb59cc1e1f1cb995ccddf071660146142f64b2a6e81037b37454c614/_data&quot;,
        &quot;Destination&quot;: &quot;/webapp&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Mode&quot;: &quot;&quot;,
        &quot;RW&quot;: true,
        &quot;Propagation&quot;: &quot;&quot;
    }
],
</pre></div>
</div>
<p>其实，在 web01 容器被删除后，/var/lib/docker/volumes/fb00ff0ceb59cc1e1f1cb995ccddf071660146142f64b2a6e81037b37454c614/_data 目录及其中的内容都还会保留下来，但是新启动的容器无法再使用这个目录，也就是说，已有的数据不能自动地被重复使用。</p>
</div></blockquote>
</li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">-v</span> <span class="pre">local_dir:container_dir</span></code> 形式 Bind mount volume</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container run --publish-all --detach --name web02 --volume /Users/renkeju/Documents/HarborCloud-docs/build/html:/usr/share/nginx/html nginx
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container inspect web02
...
&quot;Mounts&quot;: [
    {
        &quot;Type&quot;: &quot;bind&quot;,
        &quot;Source&quot;: &quot;/Users/renkeju/Documents/HarborCloud-docs/build/html&quot;,
        &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,
        &quot;Mode&quot;: &quot;&quot;,
        &quot;RW&quot;: true,
        &quot;Propagation&quot;: &quot;rprivate&quot;
    }
],
...
</pre></div>
</div>
<p>主机上的目录可以时一个本地目录，也可以在一个 NFS Share 内，或者在一个已经格式化好了的块设备上。</p>
</div></blockquote>
</li>
</ul>
<p>其实这种形式和第一种没有本质的区别，容器内对 /usr/share/nginx/html 的操作都会反应到主机的 ~/Documents/HarborCloud-docs/build/html 目录内。只是，重新启动容器时，可以再次使用同样的方式来将 ~/Documents/HarborCloud-docs/build/html 目录挂载到新的容器内，这样就可以实现数据持久化的目标。</p>
</div></blockquote>
</li>
<li><p>使用 data container</p>
<blockquote>
<div><p>如果要在容器之间共享数据，最好是使用 data container。这种 container 中不会跑应用，而只是挂载一个卷。比如：</p>
<p>创建一个 data container</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker container create --volume /dbdata --name dbstore busybox
</pre></div>
</div>
<p>启动一个 app container</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker container run --detach --publish-all --name web03 --volumes-from dbstore nginx
</pre></div>
</div>
<p>其实，对 web03 这个容器来说，volume 的本质没有变，它只是将 dbstore 容器的 /dbdata 目录映射的主机上的目录映射到自身的 /dbdata 目录。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;Mounts&quot;: [
    {
        &quot;Type&quot;: &quot;volume&quot;,
        &quot;Name&quot;: &quot;47373e7814371d703fe7a94b2282eecb3dbce122ae1faf001739231f054b8d42&quot;,
        &quot;Source&quot;: &quot;/var/lib/docker/volumes/47373e7814371d703fe7a94b2282eecb3dbce122ae1faf001739231f054b8d42/_data&quot;,
        &quot;Destination&quot;: &quot;/dbdata&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Mode&quot;: &quot;&quot;,
        &quot;RW&quot;: true,
        &quot;Propagation&quot;: &quot;&quot;
    }
],
</pre></div>
</div>
<p>这样做的优势是不管其目录的临时性而不断地重复使用它。</p>
</div></blockquote>
</li>
<li><p>使用 docker volume 命令</p>
<blockquote>
<div><p>Docker 新版本中引入了 docker volume 命令来管理 Docker volume</p>
<ul>
<li><p>使用默认的 <code class="docutils literal notranslate"><span class="pre">local</span></code> driver 创建一个 volume</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker volume create --name vol1
docker volume inspect vol1
[
    {
        &quot;CreatedAt&quot;: &quot;2018-10-30T05:05:54Z&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {},
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/vol1/_data&quot;,
        &quot;Name&quot;: &quot;vol1&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>使用这个 volume</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container run --detach --publish-all --name web04 --volume vol1:/volume nginx
</pre></div>
</div>
<p>结果还是相同，将 vol1 对应的主机上的目录挂载给容器内的 /volume 目录</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;Mounts&quot;: [
    {
        &quot;Type&quot;: &quot;volume&quot;,
        &quot;Name&quot;: &quot;vol1&quot;,
        &quot;Source&quot;: &quot;/var/lib/docker/volumes/vol1/_data&quot;,
        &quot;Destination&quot;: &quot;/volume&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Mode&quot;: &quot;z&quot;,
        &quot;RW&quot;: true,
        &quot;Propagation&quot;: &quot;&quot;
    }
],
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="volume-volume">
<h3>volume 删除和孤独 volume 清理<a class="headerlink" href="#volume-volume" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>在删除容器的时候 volume</p>
<blockquote>
<div><p>可以使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">rm</span> <span class="pre">-v</span> <span class="pre">volume_name</span></code> 命令在删除容器的时候删除该容器的卷</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker container --volumes --force web04
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker volume ls
DRIVER              VOLUME NAME
<span class="nb">local</span>               fb00ff0ceb59cc1e1f1cb995ccddf071660146142f64b2a6e81037b37454c614
<span class="nb">local</span>               vol1
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>批量删除孤独的 volumes</p>
<blockquote>
<div><p>从上面的介绍可以看出，使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--volume</span></code> 启动的容器被删除以后，在主机上会遗留下来孤单的卷。可以使用下面的简单方法来做清理：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker volume ls --quiet --filter <span class="nv">dangling</span><span class="o">=</span><span class="nb">true</span>
01e516feecef3701b84e766a21dd2988c53978e223070fed2636eaba56109c5e
b08f68c5170e417ce4c4aab6667c1aadebb4a2cf6af39099d7b7e3dc36c6b74a
fb00ff0ceb59cc1e1f1cb995ccddf071660146142f64b2a6e81037b37454c614
vol1
docker volume rm <span class="k">$(</span>docker volume ls --quiet --filter <span class="nv">dangling</span><span class="o">=</span><span class="nb">true</span><span class="k">)</span>
01e516feecef3701b84e766a21dd2988c53978e223070fed2636eaba56109c5e
b08f68c5170e417ce4c4aab6667c1aadebb4a2cf6af39099d7b7e3dc36c6b74a
fb00ff0ceb59cc1e1f1cb995ccddf071660146142f64b2a6e81037b37454c614
vol1
docker volume ls
DRIVER              VOLUME NAME
<span class="nb">local</span>               47373e7814371d703fe7a94b2282eecb3dbce122ae1faf001739231f054b8d42
</pre></div>
</div>
<p>也可以直接使用自带的清楚策略</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker volume prune
WARNING! This will remove all <span class="nb">local</span> volumes not used by at least one container.
Are you sure you want to <span class="k">continue</span>? <span class="o">[</span>y/N<span class="o">]</span> y
Deleted Volumes:
vol1

Total reclaimed space: 0B
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div>
</div>
<div class="section" id="dockerfile">
<h2>Dockerfile<a class="headerlink" href="#dockerfile" title="Permalink to this headline">¶</a></h2>
<p>从上一小节的 volume 的介绍中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令（Instruction），每一条指令构建一层 ，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>我们以定制 Nginx 镜像为例，我们使用 Dockerfile 来定制。在一个空白目录中，建立一个文本文件，并命名为 <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mkdir mynginx
$ <span class="nb">cd</span> mynginx
$ touch Dockerfile
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM nginx
RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
</pre></div>
</div>
<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<span class="guilabel">FROM</span> 和 <span class="guilabel">RUN</span> 。</p>
<div class="section" id="from">
<h3>FROM 指定基础镜像<a class="headerlink" href="#from" title="Permalink to this headline">¶</a></h3>
<p>所谓制定镜像，那一定是以一个镜像为基础，在其上进行定制。就像运行了一个 <span class="guilabel">nginx</span>，再进行修改一样，基础镜像是必须指定的。而 <span class="guilabel">RROM</span> 就是指定基础镜像，因此一个 <span class="guilabel">Dockerfile</span> 中 <span class="guilabel">FROM</span> 是必备的指令，并且必须是第一条指令。</p>
<p>在 <a class="reference external" href="https://store.docker.com/">Docker Store</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a class="reference external" href="https://store.docker.com/images/nginx">nginx</a>/<a class="reference external" href="https://store.docker.com/images/redis">redis</a>/<a class="reference external" href="https://store.docker.com/images/mongo">mongo</a>/<a class="reference external" href="https://store.docker.com/images/mysql">mysql</a>/<a class="reference external" href="https://store.docker.com/images/httpd">httpd</a>/<a class="reference external" href="https://store.docker.com/images/php">php</a> <a class="reference external" href="https://store.docker.com/images/tomcat">tomcat</a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a class="reference external" href="https://store.docker.com/images/node">node</a>/<a class="reference external" href="https://store.docker.com/images/openjdk">openjdk</a>/<a class="reference external" href="https://store.docker.com/images/python">python</a>/<a class="reference external" href="https://store.docker.com/images/ruby">ruby</a>/<a class="reference external" href="https://store.docker.com/images/golang">golang</a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a class="reference external" href="https://store.docker.com/images/ubuntu">ubuntu</a>/<a class="reference external" href="https://store.docker.com/images/debian">debian</a>/<a class="reference external" href="https://store.docker.com/images/centos">centos</a>/<a class="reference external" href="https://store.docker.com/images/fedora">fedora</a>/<a class="reference external" href="https://store.docker.com/images/alpine">alpine</a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有的镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <span class="guilabel">scratch</span> 。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM scratch
...
</pre></div>
</div>
<p>如果你以 <span class="guilabel">scratch</span> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像的第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <span class="guilabel">swarm</span> <span class="guilabel">coreos/etcd</span> 。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code class="docutils literal notranslate"><span class="pre">FROM</span> <span class="pre">scratch</span></code> 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
</div>
<div class="section" id="run">
<h3>RUN 执行命令<a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h3>
<p><span class="guilabel">RUN</span> 指令是用来执行命令行命令的。由于命令行的强大能力，<span class="guilabel">RUN</span> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><p><strong>shell</strong> 格式：<code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">&lt;command&gt;</span></code> 就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <span class="guilabel">RUN</span> 指令就是这种格式。</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>exec</strong> 格式： <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">[&quot;executable</span> <span class="pre">file&quot;,</span> <span class="pre">&quot;arg1&quot;,</span> <span class="pre">&quot;arg2&quot;]</span></code> 这更像是函数中调用的格式。</p></li>
</ul>
<p>既然 <span class="guilabel">RUN</span> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 <span class="guilabel">RUN</span> ? 比如这样：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM debian:jessie

RUN apt-get update
RUN apt-get install -y gcc lib6-dev make
RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;
RUN mkdir -p /usr/src/redis
RUN tar -zxf redis.tar.gz -C /usr/src/redis --strip-components=1
RUN make -C /usr/src/redis
RUN make -C /usr/src/redis install
</pre></div>
</div>
<p>之前说过，Dockerfile 中每一个指令都会建立一层，<span class="guilabel">RUN</span> 也不例外。每一个 <span class="guilabel">RUN</span> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后， <code class="docutils literal notranslate"><span class="pre">commit</span></code> 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了7层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加构建部署的时间，也很容易出错。这是很多 Docker 初学者常犯的一个错误。</p>
<p>Union FS 是有**最大层数限制**的，比如 AUFS，之前是最大不得超过 42 层，现在是不得超过 127 层。
上面的 <span class="guilabel">Dockerfile</span> 正确的写法应该是这样的：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM debian:jessie

RUN buildDeps=&#39;gcc libec6-dev make&#39; \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y $buildDeps \
    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \
    &amp;&amp; mkdir -p /usr/src/redis \
    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    &amp;&amp; make -C /usr/src/redis \
    &amp;&amp; make -C /usr/src/redis install \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r /usr/src/redis \
    &amp;&amp; apt-get purge -y --auto-remove $buildDeps
</pre></div>
</div>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用多个 <code class="docutils literal notranslate"><span class="pre">RUN</span></code> 一一对应不同的命令，而是仅仅使用一个 <code class="docutils literal notranslate"><span class="pre">RUN``指令，并使用</span> <span class="pre">``&amp;&amp;</span></code> 将各个所需命令串联起来。将之前的 7 层，简化为 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code class="docutils literal notranslate"><span class="pre">\</span></code> 的换行符命令方式，以及行首 <code class="docutils literal notranslate"><span class="pre">#</span></code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <span class="guilabel">apt</span> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>Docker 初学者制作的 Docker 镜像非常臃肿的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
</div>
<div class="section" id="id16">
<h3>构建镜像<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像。</p>
<p>在 <span class="guilabel">Dockerfile</span> 文件所在目录执行：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build -t nginx:v3 .
Sending build context to Docker daemon  2.048kB
Step 1/2 : FROM nginx:1.14-alpine
---&gt; 14d4a58e0d2e
Step 2/2 : RUN echo &#39;&lt;h1&gt;Hello, World!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
---&gt; Running in 56c88dfe6001
Removing intermediate container 56c88dfe6001
---&gt; 4987c2fc5455
Successfully built 4987c2fc5455
Successfully tagged nginx:v3
</pre></div>
</div>
<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <span class="guilabel">Step 2</span> 中，如同我们之前所说的那样，<span class="guilabel">RUN</span> 指令启动了一个容器 <code class="docutils literal notranslate"><span class="pre">14d4a58e0d2e</span></code> ，执行了所要求的命令，并最后提交了这一层 <code class="docutils literal notranslate"><span class="pre">56c88dfe6001</span></code> ，随后删除了所用到的这个容器 <code class="docutils literal notranslate"><span class="pre">14d4a58e0d2e</span></code> 。</p>
<p>这里我们使用了 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code> 命令进行镜像构建，其格式为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker [--host [socket|tcp]] image build [options] &lt;Dockerfile_Context/URL/-&gt;
</pre></div>
</div>
<p>在这里我们指定了最终镜像的名称 <code class="docutils literal notranslate"><span class="pre">--tag</span> <span class="pre">nginx:v3</span></code> ，构建成功后，我们可以运行 <code class="docutils literal notranslate"><span class="pre">nginx:v3</span></code> 镜像。</p>
</div>
<div class="section" id="context">
<h3>镜像构建上下文（Context）<a class="headerlink" href="#context" title="Permalink to this headline">¶</a></h3>
<p>如果注意，会看到 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令最后一个 <code class="docutils literal notranslate"><span class="pre">.</span></code> 。 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示当前目录，而 <span class="guilabel">Dockerfile</span> 就在当前目录，因此不少初学者以为这个路径时在指定 <span class="guilabel">Dockerfile</span> 所在路径，这样理解不准确。如果对应上面的命令格式，你会发现，这是在指定**上下文路径**。为什么时上下文？</p>
<p>首先我们要理解 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如  <code class="docutils literal notranslate"><span class="pre">docker</span></code> 命令这样的客户端工作，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像时在本机执行各种 <code class="docutils literal notranslate"><span class="pre">docker</span></code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <span class="guilabel">RUN</span> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <span class="guilabel">COPY</span> 指令、<span class="guilabel">ADD</span> 指令等。而 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是说 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令得知这个路径后，会将路径下的所有内容打包，然后上穿给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 <span class="guilabel">Dockerfile</span> 中这么写：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>COPY ./package.json /app/
</pre></div>
</div>
<p>这并不是要复制执行 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令所在的目录下的 package.json，也不是复制 <span class="guilabel">Dockerfile</span> 所在目录下的 package.json，而是复制 <strong>上下文（context）</strong> 目录下的 package.json 。</p>
<p>因此，<span class="guilabel">COPY</span> 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问为什么 <code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">../package.json</span> <span class="pre">/app</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">/opt/xxxx</span> <span class="pre">/app</span></code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span> <span class="pre">--tag</span> <span class="pre">nginx:v3</span> <span class="pre">.</span></code> 中这个 <code class="docutils literal notranslate"><span class="pre">.</span></code> ，实际上是在指定上下文的目录，<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令会将该目录心爱的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 输出，我们其实已经看到了这个发送上下文的过程：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build -t nginx:v3 .
Sending build context to Docker daemon  2.048kB
</pre></div>
</div>
<p>理解构建上下文对镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">/opt/xxxx</span> <span class="pre">/app</span></code> 不工作后，于是干脆将 <span class="guilabel">Dockerfile</span> 放到了硬盘根目录去构建，结果发现 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 执行后，在发送一个几十GB的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该将 <span class="guilabel">Dockerfile</span> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code class="docutils literal notranslate"><span class="pre">.gitignore</span></code> 一样的语法写一个 <code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code> ，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 <code class="docutils literal notranslate"><span class="pre">.</span></code> 是指定 <span class="guilabel">Dockerfile</span> 所在目录呢？这是因为在默认情况下，如果并不要求必须位于上下文目录中，比如可以用 <code class="docutils literal notranslate"><span class="pre">-f</span> <span class="pre">../Dockerfile.php</span></code> 参数指定某个文件作为 <span class="guilabel">Dockerfile</span>。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 <span class="guilabel">Dockerfile</span>，以及会将其置于镜像构建上下文目录中。</p>
</div>
<div class="section" id="id17">
<h3>其他构建镜像方法<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>直接用 Git repo 进行构建</p>
<blockquote>
<div><p>或许你已经注意到了， <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build https://github.com/jenkinsci/jenkins.git\#jenkins-2.149
Sending build context to Docker daemon   60.3MB
Step 1/17 : FROM maven:3.5.4-jdk-8 as builder
---&gt; 985f3637ded4
Step 2/17 : COPY .mvn/ /jenkins/src/.mvn/
---&gt; Using cache
---&gt; 449d4e56d53e
Step 3/17 : COPY cli/ /jenkins/src/cli/
---&gt; Using cache
---&gt; 841e76c4f7d8
Step 4/17 : COPY core/ /jenkins/src/core/
---&gt; Using cache
---&gt; b6b7d47e8294
Step 5/17 : COPY src/ /jenkins/src/src/
---&gt; Using cache
---&gt; e7a46ef570cf
Step 6/17 : COPY test/ /jenkins/src/test/
---&gt; Using cache
---&gt; e1d52ec3c4ad
Step 7/17 : COPY war/ /jenkins/src/war/
---&gt; Using cache
---&gt; 3e24961339fc
Step 8/17 : COPY *.xml /jenkins/src/
...
</pre></div>
</div>
<p>这行命令指定了构建所需的 Git repo，并且指定默认的 <span class="guilabel">master</span> 分支，构建目录为 <code class="docutils literal notranslate"><span class="pre">/jenkins-2.149/</span></code> ，然后 Docker 就会自己去 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span></code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
</div></blockquote>
</li>
<li><p>用给定的 tar 压缩包构建</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker image build http://server/context.tar.gz
</pre></div>
</div>
<p>如果给出的 URL 不是 Git repo，而是个 tar 压缩包，那么 docker 引擎会下载这个压缩包，并自动解压缩，以其作为上下文，开始构建。</p>
</div></blockquote>
</li>
<li><p>从标准输入中读取 Dockerfile 进行构建</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker image build - &lt; Dockerfile
// 或者
cat Dockerfile | docker image build -
</pre></div>
</div>
<p>如果标准输入传入的是文本文件，则将其视为 <span class="guilabel">Dockerfile</span> ，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 内容，它没有上下文，因此不可以像其他方法那样将本地文件 <span class="guilabel">COPY</span> 进镜像之类的事情。</p>
</div></blockquote>
</li>
<li><p>从标准输入中读取上下文压缩包进行构建</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build - &lt; context.tar.gz
</pre></div>
</div>
<p>如果发现标准输入的文件格式是 <span class="guilabel">gzip</span> <span class="guilabel">bzip2</span> 以及 <span class="guilabel">xz</span> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="id18">
<h2>Dockerfile 指令<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<p>我们已经介绍了 <span class="guilabel">FROM</span>、<span class="guilabel">RUN</span>，还提及了 <span class="guilabel">COPY</span>、<span class="guilabel">ADD</span>，其实 <span class="guilabel">Dockerfile</span> 功能很强大，它提供了十多个指令。下面我们继续学习其他的指令。</p>
<div class="section" id="copy">
<h3>COPY 复制文件<a class="headerlink" href="#copy" title="Permalink to this headline">¶</a></h3>
<p>格式：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">&lt;source_path&gt;...</span> <span class="pre">&lt;destination_path&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">[&quot;&lt;source_path_01&gt;&quot;,...</span> <span class="pre">&quot;&lt;destination_path&gt;&quot;]</span></code></p></li>
</ul>
<p>和 <span class="guilabel">RUN</span> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p><span class="guilabel">COPY</span> 指令将从构建上下文目录中 <code class="docutils literal notranslate"><span class="pre">&lt;source_path&gt;</span></code> 的文件/目录复制到新的一层的镜像内 <code class="docutils literal notranslate"><span class="pre">&lt;destination_path&gt;</span></code> 位置。比如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>COPY package.json /usr/src/app
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;destination_path&gt;</span></code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <span class="guilabel">WORKDIR</span> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先进行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <span class="guilabel">COPY</span> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
</div>
<div class="section" id="add">
<h3>ADD 更高级的复制文件<a class="headerlink" href="#add" title="Permalink to this headline">¶</a></h3>
<p><span class="guilabel">ADD</span> 指令和 <span class="guilabel">COPY</span> 的格式和性质基本一致。但是在 <span class="guilabel">COPY</span> 基础上增加了一些功能。</p>
<p>比如 <code class="docutils literal notranslate"><span class="pre">&lt;source_path&gt;</span></code> 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code class="docutils literal notranslate"><span class="pre">&lt;destination_path&gt;</span></code> 去。下载后的文件权限自动设置为 <strong>600</strong>，如果这并不是想要的权限，那么还需要增加额外的一层 <span class="guilabel">RUN</span> 指令进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <span class="guilabel">RUN</span> 指令进行解压缩。所以不如直接使用 <span class="guilabel">RUN</span> 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">&lt;source_path&gt;</span></code> 为一个 tar 压缩文件的话，压缩格式为 <code class="docutils literal notranslate"><span class="pre">gzip</span></code> <code class="docutils literal notranslate"><span class="pre">bzip2</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">xz</span></code>
的情况下，<span class="guilabel">ADD</span> 指令将会自动解压缩这个压缩文件到 <code class="docutils literal notranslate"><span class="pre">&lt;destination_path&gt;</span></code> 去。</p>
<p>在某些情况下，这个自动解压缩的功能非常游泳，比如官方镜像 <a class="reference external" href="https://github.com/tianon/docker-brew-ubuntu-core/blob/c7e9f7353aa24d1c35f501e06382aed1b540e85f/bionic/Dockerfile">ubuntu Dockerfile</a> 中：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM scratch
ADD ubuntu-bionic-core-cloudimg-amd64-root.tar.gz /
...
</pre></div>
</div>
<p>但在某些情况下，如果我们真的希望复制这个压缩文件进去，而不解压缩，这时就不可以使用 <span class="guilabel">ADD</span> 命令了。</p>
<p>在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 <span class="guilabel">COPY</span>，因为 <span class="guilabel">COPY</span> 的语义很明确，就是复制文件而已，而 <span class="guilabel">ADD</span> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <span class="guilabel">ADD</span> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<span class="guilabel">ADD</span> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <span class="guilabel">COPY</span> 和 <span class="guilabel">ADD</span> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <span class="guilabel">COPY</span> 指令，仅在需要自动解压缩的场合使用 <span class="guilabel">ADD</span>。</p>
</div>
<div class="section" id="cmd">
<h3>CMD 容器启动命令<a class="headerlink" href="#cmd" title="Permalink to this headline">¶</a></h3>
<p><span class="guilabel">CMD</span> 指令的格式和 <span class="guilabel">RUN</span> 相似，也是两种格式：</p>
<ul class="simple">
<li><p><strong>shell</strong> 格式： <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">&lt;command&gt;</span></code></p></li>
<li><p><strong>exec</strong> 格式： <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">[&quot;executable&quot;,</span> <span class="pre">&quot;arg1&quot;,</span> <span class="pre">&quot;arg2&quot;...]</span></code></p></li>
<li><p>参数列表格式： <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">[&quot;arg1&quot;,</span> <span class="pre">&quot;arg2&quot;...]</span></code> 在指定了 <span class="guilabel">ENTRYPOINT</span> 指令后，用 <span class="guilabel">CMD</span> 指定具体的参数。</p></li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<span class="guilabel">CMD</span> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置重的这个默认命令，比如，<a class="reference external" href="https://store.docker.com/images/ubuntu">ubuntu</a> 镜像默认的 <span class="guilabel">CMD</span> 是 <code class="docutils literal notranslate"><span class="pre">/bin/bash</span></code> ，如果我们直接 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--tty</span> <span class="pre">--interactive</span> <span class="pre">ubuntu</span></code> 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--tty</span> <span class="pre">--interactive</span> <span class="pre">ubuntu</span> <span class="pre">cat</span> <span class="pre">/etc/os-release</span></code> 。这就是用 <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/etc/os-release</span></code> 命令替换了默认的 <code class="docutils literal notranslate"><span class="pre">/bin/bash</span></code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <strong>exec</strong> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用 <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> ，而不要使用单引号。</p>
<p>如果使用 <strong>shell</strong> 格式的话，实际的命令会被包装为 <code class="docutils literal notranslate"><span class="pre">sh</span> <span class="pre">-c</span></code> 的参数的形式进行执行。比如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CMD echo $HOME
</pre></div>
</div>
<p>在实际执行中，会将其变更为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]
</pre></div>
</div>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <span class="guilabel">CMD</span> 就不得不提容器中应用在前台执行和后台执行的问题。初学者常常会混淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该在前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <span class="guilabel">CMD</span> 写为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CMD service nginx start
</pre></div>
</div>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其他辅助进程不是它需要关心的东西。</p>
<p>而使用 <code class="docutils literal notranslate"><span class="pre">service</span> <span class="pre">nginx</span> <span class="pre">start</span></code> 命令，则是希望 upstart 以后台守护进程的形式启动 nginx 服务。而刚才说了 <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">service</span> <span class="pre">nginx</span> <span class="pre">start</span></code> 会被理解为 <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">[</span> <span class="pre">&quot;sh&quot;,</span> <span class="pre">&quot;-c&quot;,</span> <span class="pre">&quot;service</span> <span class="pre">nginx</span> <span class="pre">start&quot;</span> <span class="pre">]</span></code> ，因此主进程实际上是 <code class="docutils literal notranslate"><span class="pre">sh</span></code> 。那么当 <code class="docutils literal notranslate"><span class="pre">service</span> <span class="pre">ngin</span> <span class="pre">start</span></code> 命令结束后， <code class="docutils literal notranslate"><span class="pre">sh</span></code> 也就结束了， <code class="docutils literal notranslate"><span class="pre">sh</span></code> 作为住进称退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CMD [ &quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot; ]
</pre></div>
</div>
</div>
<div class="section" id="entrypoint">
<h3>ENTRYPOINT 入口点<a class="headerlink" href="#entrypoint" title="Permalink to this headline">¶</a></h3>
<p><span class="guilabel">ENTRYPOINT</span> 的格式和 <span class="guilabel">RUN</span> 指令格式一样，分别为 <strong>exec</strong> 格式和 <strong>shell</strong> 格式。</p>
<p><span class="guilabel">ENTRYPOINT</span> 的目的和 <span class="guilabel">CMD</span> 一样，都是在指定容器启动程序及参数。<span class="guilabel">ENTRYPOINT</span> 在运行时也可以替代，不过比 <span class="guilabel">CMD</span> 要略显繁琐，需要通过 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span></code> 的参数 <code class="docutils literal notranslate"><span class="pre">--entrypoint</span></code> 来指定。</p>
<p>当指定了 <span class="guilabel">ENTRYPOINT</span> 后，<span class="guilabel">CMD</span> 的含义就发生了改变，不再是直接的运行其命令，而是将 <span class="guilabel">CMD</span> 的内容作为参数传给 <span class="guilabel">ENTRYPOINT</span> 指令，换句话说实际执行时，将变为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;
</pre></div>
</div>
<p>那么有了 <span class="guilabel">CMD</span> 后，为什么还要有 <span class="guilabel">ENTRYPOINT</span> 呢？这种 <code class="docutils literal notranslate"><span class="pre">&lt;ENTRTYPOINT&gt;</span> <span class="pre">&lt;CMD&gt;</span></code> 有什么好处？让我们来看几个场景。</p>
<ul>
<li><p>场景一：让镜像变成像命令一样使用</p>
<blockquote>
<div><p>假设我们需要一个得知自己当前公网IP的镜像，那么可以先用 <span class="guilabel">CMD</span> 来实现：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM ubuntu:16.04
RUN apt-get update \
    &amp;&amp; apt-get install -y curl \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
CMD [&quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot;]
</pre></div>
</div>
<p>假如我们使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span> <span class="pre">--tag=myip</span> <span class="pre">.</span></code> 来构建镜像的话，如果我们需要查询当前公网IP，只需要执行：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container run --rm --name myip_test myip:1.0
当前 IP: 58.246.147.26 来自: 上海市 联通
</pre></div>
</div>
<p>嗯，这么看起来我们好像直接把镜像当作命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <span class="guilabel">CMD</span> 中可以看到实质的命令时 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 参数。那么我们可以直接加入 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 参数给 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">myip</span></code> 吗？</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container run --rm --name myip_test myip:1.0 -i
docker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: \&quot;-i\&quot;: executable file not found in $PATH&quot;: unknown.
</pre></div>
</div>
<p>我们可以看到可执行文件找不到的报错，<code class="docutils literal notranslate"><span class="pre">executable</span> <span class="pre">file</span> <span class="pre">not</span> <span class="pre">found</span></code> 。之前我们说过，跟在镜像名后面的是 command，运行时会替换 <span class="guilabel">CMD</span> 的默认值。因此这里的 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 替换了原来的 <span class="guilabel">CMD</span> ，而不是添加在原来的 <code class="docutils literal notranslate"><span class="pre">curl</span> <span class="pre">-s</span> <span class="pre">http://ip.cn</span></code> 后面。而 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 这参数，我们就必须重新完整的输入这个命令：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker container run --rm --name myip_test myip:1.0 curl -s http://ip.cn -i
HTTP/1.1 200 OK
Date: Thu, 01 Nov 2018 02:59:52 GMT
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Set-Cookie: __cfduid=d8b77ba972fb91bec979f9a212ceca6841541041192; expires=Fri, 01-Nov-19 02:59:52 GMT; path=/; domain=.ip.cn; HttpOnly
Server: cloudflare
CF-RAY: 472b1b9af36b9619-SJC

当前 IP: 58.246.147.26 来自: 上海市 联通
</pre></div>
</div>
<p>这显然不是很好的解决方案，而使用 <span class="guilabel">ENTRYPOINT</span> 就可以解决这个问题。现在我们重新用 <span class="guilabel">ENTRYPOINT</span> 来实现这个镜像：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM ubuntu:16.04

RUN apt-get update \
    &amp;&amp; apt-get install -y curl \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]
</pre></div>
</div>
<p>这次我们再来尝试直接使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">myip</span> <span class="pre">-i</span></code> 。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker container run --rm --name myip_test myip:1.1
当前 IP: 58.246.147.26 来自: 上海市 联通

$ docker container run --rm --name myip_test myip:1.1 -i
HTTP/1.1 200 OK
Date: Thu, 01 Nov 2018 03:17:16 GMT
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Set-Cookie: __cfduid=d89a29d9467d6f00d7856b8a8f22d10791541042236; expires=Fri, 01-Nov-19 03:17:16 GMT; path=/; domain=.ip.cn; HttpOnly
Server: cloudflare
CF-RAY: 472b351850169668-SJC

当前 IP: 58.246.147.26 来自: 上海市 联通
</pre></div>
</div>
<p>可以看到，这次成功了。这是因为当存在 <span class="guilabel">ENTRYPOINT</span> 后，<span class="guilabel">CMD</span> 的内容将会作为参数传给 <span class="guilabel">ENTRYPOINT</span>，而这里 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 就是新的 <span class="guilabel">CMD</span>，因为会作为参数传给 curl，从而达到了我们预期的效果。</p>
</div></blockquote>
</li>
<li><p>场景二：应用运行前的准备工作</p>
<blockquote>
<div><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 <span class="guilabel">root</span> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务之外，其他命令依旧可以使用 root 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 <span class="guilabel">CMD</span> 无关的，无论 <span class="guilabel">CMD</span> 是什么，都需要事先进行一个预处理工作。这种情况下，可以写一个脚本，然后放入 <span class="guilabel">ENTRYPOINT</span> 中执行，而这个脚本会将接收到的参数（也就是 <span class="guilabel">&lt;CMD&gt;</span>）作为命令，在脚本最后执行。比如官方镜像 <a class="reference external" href="https://github.com/docker-library/redis/blob/dc6dc737baa434528ce31948b22b4c6ccc78793a/5.0/Dockerfile">redis Dockerfile</a> 中就是这么做的：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM alpine:3.4
...
RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis
...
ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]

EXPOSE 6379
CMD [ &quot;redis-server&quot; ]
</pre></div>
</div>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <span class="guilabel">ENTRYPOINT</span> 为 <code class="docutils literal notranslate"><span class="pre">docker-entrypoint.sh</span></code> 脚本。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="nb">set</span> -e

<span class="c1"># first arg is `-f` or `--some-option`</span>
<span class="c1"># or first arg is `something.conf`</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">1</span><span class="p">#-</span><span class="si">}</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">]</span> <span class="o">||</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">1</span><span class="p">%.conf</span><span class="si">}</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">set</span> -- redis-server <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
<span class="k">fi</span>

<span class="c1"># allow the container to be started with `--user`</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s1">&#39;redis-server&#39;</span> -a <span class="s2">&quot;</span><span class="k">$(</span>id -u<span class="k">)</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    find . <span class="se">\!</span> -user redis -exec chown redis <span class="s1">&#39;{}&#39;</span> +
    <span class="nb">exec</span> gosu redis <span class="s2">&quot;</span><span class="nv">$0</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
<span class="k">fi</span>

<span class="nb">exec</span> <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>该脚本的内容就是根据 <span class="guilabel">CMD</span> 的内容来判断，如果是 <code class="docutils literal notranslate"><span class="pre">redis-server</span></code> 的话，则切换到 <code class="docutils literal notranslate"><span class="pre">redis</span></code> 用户身份启动服务，否则依旧使用 root 身份执行。比如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker container run --detach --publish-all --name kvstore redis:4.0-alpine
1656bd2427fcc96e3e9dbdaf0e498786ca8817b5bb97e200476c555a117964c5

$ docker container exec kvstore id
uid=0(root) gid=0(root)
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="env">
<h3>ENV 设置环境变量<a class="headerlink" href="#env" title="Permalink to this headline">¶</a></h3>
<p>格式有两种：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ENV</span> <span class="pre">&lt;key&gt;</span> <span class="pre">&lt;value&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENV</span> <span class="pre">&lt;key1&gt;=&lt;value1&gt;</span> <span class="pre">&lt;key2&gt;=&lt;value2&gt;...</span></code></p></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其他指令，如 <span class="guilabel">RUN</span>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ENV VERSION=1.0 DEBUG=on \
    NAME=&quot;Happy Feet&quot;
</pre></div>
</div>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号扩起来的办法，这和 Shell 下的行为是一致的。</p>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ENV NODE_VERSION 7.2.0

RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.gz&quot; \
    &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; \
    &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \
    &amp;&amp; grep &quot;node -v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c - \
    &amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C /usr/local --strip-components=1 \
    &amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \
    &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs
</pre></div>
</div>
<p>在这里先定义了环境变量 <code class="docutils literal notranslate"><span class="pre">NODE_VERSION</span></code> ，其后的 <span class="guilabel">RUN</span> 这层里，多次使用 <code class="docutils literal notranslate"><span class="pre">$NODE_VERSION</span></code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <span class="guilabel">7.2.0</span> 即可，<span class="guilabel">Dockerfile</span> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量的展开：</p>
<ol class="arabic simple">
<li><p>ADD</p></li>
<li><p>COPY</p></li>
<li><p>ENV</p></li>
<li><p>EXPOSE</p></li>
<li><p>LABEL</p></li>
<li><p>USER</p></li>
<li><p>WORKDIR</p></li>
<li><p>VOLUME</p></li>
<li><p>STOPSIGNAL</p></li>
<li><p>ONBUILD</p></li>
</ol>
<p>可以从这个指令列表感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <span class="guilabel">Dockerfile</span> 制作更多的镜像，只需使用不同的环境变量即可。</p>
</div>
<div class="section" id="arg">
<h3>ARG 构建参数<a class="headerlink" href="#arg" title="Permalink to this headline">¶</a></h3>
<p>格式： <code class="docutils literal notranslate"><span class="pre">ARG</span> <span class="pre">&lt;parameter&gt;[=&lt;defaults&gt;]</span></code></p>
<p>构建参数和 <span class="guilabel">ENV</span> 的效果一样，都是设置环境变量。所不同的是，<span class="guilabel">ARG</span> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <span class="guilabel">ARG</span> 保存密码之类的信息，因为 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">history</span> <span class="pre">IMAGE:TAG</span></code> 还是可以看到所有值的。</p>
<p><span class="guilabel">Dockerfile</span> 中的 <span class="guilabel">ARG</span> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 中用 <code class="docutils literal notranslate"><span class="pre">--build-arg</span> <span class="pre">&lt;parameter&gt;=&lt;value&gt;</span></code> 来覆盖。</p>
<p>在 <strong>1.13</strong> 之前的版本，要求 <code class="docutils literal notranslate"><span class="pre">--build-arg``中的参数名，必须在</span> <span class="pre">:guilabel:`Dockerfile`</span> <span class="pre">中用</span> <span class="pre">:guilabel:`ARG`</span> <span class="pre">定义过了，换句话说，就是</span> <span class="pre">``--build-arg</span></code> 指定的参数，必须在 <span class="guilabel">Dockerfile</span> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 <strong>1.13</strong> 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <span class="guilabel">Dockerfile</span> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p>
</div>
<div class="section" id="id20">
<h3>VOLUME 定义匿名卷<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>格式为：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">VOLUME</span> <span class="pre">[&quot;&lt;path1&gt;&quot;,</span> <span class="pre">&quot;path2&quot;...]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VOLUME</span> <span class="pre">&lt;path&gt;</span></code></p></li>
</ul>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷（volume）中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <span class="guilabel">Dockerfile</span> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VOLUME /data
</pre></div>
</div>
<p>这里的 <code class="docutils literal notranslate"><span class="pre">/data</span></code> 目录就会在运行时自动挂载为匿名卷，任何向 <code class="docutils literal notranslate"><span class="pre">/data</span></code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container --detach --volume mydata:/data xxxx
</pre></div>
</div>
<p>在这行命令中，就使用了 <code class="docutils literal notranslate"><span class="pre">mydata</span></code> 这个命名卷挂载到了 <code class="docutils literal notranslate"><span class="pre">/data</span></code> 这个位置，替代了 <span class="guilabel">Dockerfile</span> 中定义的匿名卷的挂载配置。</p>
</div>
<div class="section" id="expose">
<h3>EXPOSE 声明端口<a class="headerlink" href="#expose" title="Permalink to this headline">¶</a></h3>
<p>格式为 <code class="docutils literal notranslate"><span class="pre">EXPOSE</span> <span class="pre">&lt;port_1&gt;</span> <span class="pre">[&lt;port_2&gt;...]</span></code></p>
<p><span class="guilabel">EXPOSE</span> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 <span class="guilabel">Dockerfile</span> 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用户则是在运行时使用随机端口映射时，也就是 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--publish-all</span></code> 时，会自动随机映射 <span class="guilabel">EXPOSE</span> 的端口。</p>
<p>此外，在早期 Docker 版本中还有一个特殊的用处。以前所有的容器都运行于默认桥接网络中，因此所有容器相互之间都可以之间访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 <code class="docutils literal notranslate"><span class="pre">--icc=false</span></code> ，当指定该参数后，容器间将默认无法互相访问，除非互相之间使用了 <code class="docutils literal notranslate"><span class="pre">--links</span></code> 参数的容器才可以互通，并且只有镜像中 <span class="guilabel">EXPOSE</span> 所声明的端口才可以被访问。这个 <code class="docutils literal notranslate"><span class="pre">--icc=false</span></code> 的用法，在引入了 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">network</span></code> 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联于隔离。</p>
<p>要将 <span class="guilabel">EXPOSE</span> 和在运行时使用 <code class="docutils literal notranslate"><span class="pre">--publish</span> <span class="pre">port_list</span></code> 区分开来。<code class="docutils literal notranslate"><span class="pre">--publish</span></code> 是映射宿主机端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <span class="guilabel">EXPOSE</span> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主机进行端口映射。</p>
</div>
<div class="section" id="workdir">
<h3>WORKDIR 指定工作目录<a class="headerlink" href="#workdir" title="Permalink to this headline">¶</a></h3>
<p>格式为 <code class="docutils literal notranslate"><span class="pre">WORKDIR</span> <span class="pre">&lt;work</span> <span class="pre">directory</span> <span class="pre">path&gt;</span></code></p>
<p>使用 <span class="guilabel">WORKDIR</span> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<span class="guilabel">WORKDIR</span> 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> 等同于 Shell 脚本来书写，这种错误的理解还能会导致出现下面这样的错误：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RUN cd /app
RUN echo &quot;hello&quot; &gt; world.txt
</pre></div>
</div>
<p>如果将这个 “Dockerfile” 进行构建镜像运行后，会发现找不到 <code class="docutils literal notranslate"><span class="pre">/app/world.txt</span></code> 文件，或者其内容不是 hello。其原因很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <span class="guilabel">Dockerfile</span> 中，这两行 <span class="guilabel">RUN</span> 命令在执行环境根本不同，式两个完全不同的容器。这就是对 <span class="guilabel">Dockerfile</span> 构建分层存储的概念不了解所导致的。</p>
<p>之前说过每一个 <span class="guilabel">RUN</span> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">cd</span> <span class="pre">/app</span></code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没有关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code> 指令。</p>
</div>
<div class="section" id="user">
<h3>USER 指定当前用户<a class="headerlink" href="#user" title="Permalink to this headline">¶</a></h3>
<p>格式： <code class="docutils literal notranslate"><span class="pre">USER</span> <span class="pre">&lt;username&gt;</span></code></p>
<p><span class="guilabel">USER</span> 指令和 <span class="guilabel">WORKDIR</span> 相似，都是改变环境状态并影响以后的层。<span class="guilabel">WORKDIR</span> 是改变工作目录，<span class="guilabel">USER</span> 则是改变之后层的执行 <span class="guilabel">RUN</span> 指令，<span class="guilabel">CMD</span> 以及 <span class="guilabel">ENTRYPOINT</span> 这类命令的身份。</p>
<p>当然，和 <span class="guilabel">WORKDIR</span> 一样，<span class="guilabel">USER</span> 只是帮助你切换指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis
USER redis
RUN [ &quot;redis-server&quot; ]
</pre></div>
</div>
<p>如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo ，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># 建立 redis 用户，并使用 gosu 换另一个用户执行命令
RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis
# 下载 gosu
RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \
    &amp;&amp; chmod +x /usr/local/bin/gosu \
    &amp;&amp; gosu nobody true
# 设置 CMD，并以另外的用户执行
CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]
</pre></div>
</div>
</div>
<div class="section" id="healthcheck">
<h3>HEALTHCHECK 健康检查<a class="headerlink" href="#healthcheck" title="Permalink to this headline">¶</a></h3>
<p>格式：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">[option]</span> <span class="pre">CMD</span> <span class="pre">&lt;COMMAND&gt;</span></code> 设置检查容器监控状态的命令</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">NONE</span></code> 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</p></li>
</ul>
<p><span class="guilabel">HEALTHCHECK</span> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是从 <strong>Docker 1.12</strong> 引入的新指令。</p>
<p>在没有 <span class="guilabel">HEALTHCHECK</span> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下没有问题，但是如果程序进入了死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 <strong>1.12</strong> 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 <strong>1.12</strong> 之后，Docker 提供了 <span class="guilabel">HEALTHCHECK</span> 指令后，用其启动容器，初始状态会为 <span class="guilabel">starting</span>，在 <span class="guilabel">HEALTHCHECK</span> 指令检查成功后变为 <span class="guilabel">healthy</span> ，如果连续一定次数失败，则会变为 <span class="guilabel">unhealthy</span>。</p>
<p><span class="guilabel">HEALTHCHECK</span> 支持下列选项：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">--interval=&lt;second&gt;</span></code> 两次健康检查的间隔，默认为 30 秒；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--timeout=&lt;second&gt;</span></code> 健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--retries=&lt;number&gt;</span></code> 当连续失败指定次数后，则将容器状态视为 <span class="guilabel">unhealthy</span>，默认 3 次。</p></li>
</ul>
<p>和 <span class="guilabel">CMD</span> <span class="guilabel">ENTRYPOINT</span> 一样，<span class="guilabel">HEALTHCHECK</span> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">[option]</span> <span class="pre">CMD</span></code> 后面的命令，格式和 <span class="guilabel">ENTRYPOINT</span> 一样，分为 <strong>shell</strong> 格式，和 <strong>exec</strong> 格式。命令的返回值决定了该次健康检查的成功与否</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>code</p></th>
<th class="head"><p>status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>success</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>fail</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>save</p></td>
</tr>
</tbody>
</table>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>不要使用 2 这个值</p>
</div>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 <span class="guilabel">Dockerfile</span> 的 <span class="guilabel">HEALTHCHECK</span> 可以这么写：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM nginx:1.14.0

RUN apt-get update \
    &amp;&amp; apt-get install -y curl \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

HEALTHCHECK --interval=5s --timeout=3s \
        CMD curl -fs http://localhost/ || exit 1
</pre></div>
</div>
<p>这里我们设置了每5秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过3秒没有响应就视为失败，并且使用 <code class="docutils literal notranslate"><span class="pre">curl</span> <span class="pre">-fs</span> <span class="pre">http://localhost/</span> <span class="pre">||</span> <span class="pre">exit</span> <span class="pre">1</span></code> 作为健康检查命令。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 来构建这个镜像：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker image build --tag=myweb:1.0 .
</pre></div>
</div>
<p>构建完成之后，我们启动一个容器：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>container run --detach --publish 80:80 --name myweb_test myweb:1.0
</pre></div>
</div>
<p>当运行该镜像后，可以通过 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">ls</span></code> 看到最初的状态为 <code class="docutils literal notranslate"><span class="pre">(health:</span> <span class="pre">starting)</span></code> ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container ls
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                   PORTS                     NAMES
6d9d2d0557de        myweb:1.0           &quot;nginx -g &#39;daemon of…&quot;   10 seconds ago      Up 9 seconds (healthy)   0.0.0.0:80-&gt;80/tcp        myweb_test
</pre></div>
</div>
<p>在等待几秒钟后，再次 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">ls</span></code> 就会看到健康状态变化为了 <code class="docutils literal notranslate"><span class="pre">(healthy)</span></code> ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container ls
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS                     NAMES
6d9d2d0557de        myweb:1.0           &quot;nginx -g &#39;daemon of…&quot;   22 seconds ago      Up 21 seconds (healthy)   0.0.0.0:80-&gt;80/tcp        myweb_test
</pre></div>
</div>
<p>如果健康检查连续失败超过了重试次数，状态就会变为 <code class="docutils literal notranslate"><span class="pre">(unhealthy)</span></code> 。</p>
<p>为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr） 都会被存储在健康状态里，可以用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">inspect</span> <span class="pre">CONTAINER</span></code> 来查看。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container inspect --format &#39;{{json .State.Health}}&#39; myweb_test | python -m json.tool
{
    &quot;Status&quot;: &quot;healthy&quot;,
    &quot;FailingStreak&quot;: 0,
    &quot;Log&quot;: [
        {
            &quot;Start&quot;: &quot;2018-11-01T09:13:48.06308Z&quot;,
            &quot;End&quot;: &quot;2018-11-01T09:13:48.1525581Z&quot;,
            &quot;ExitCode&quot;: 0,
            &quot;Output&quot;: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\&quot;http://nginx.org/\&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\&quot;http://nginx.com/\&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;
        },
        ...
    ]
}
</pre></div>
</div>
</div>
<div class="section" id="onbuild">
<h3>ONBUILD 为他人做嫁衣裳<a class="headerlink" href="#onbuild" title="Permalink to this headline">¶</a></h3>
<p>格式： <code class="docutils literal notranslate"><span class="pre">ONBUILD</span> <span class="pre">&lt;other_instruction&gt;</span></code></p>
<p><span class="guilabel">ONBUILD</span> 是一个特殊的指令，它后面跟的是其他指令，比如 <span class="guilabel">RUN</span>，<span class="guilabel">COPY</span> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p><span class="guilabel">Dockerfile</span> 中的其他指令都是为了定制当前镜像而准备的，唯有 <span class="guilabel">ONBUILD</span> 是为了帮助别人定制自己而准备的。</p>
<p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里 文件里。在拿到程序代码后，需要先进行 <code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">install</span></code> 才可以获取所有需要的依赖。然后就可以通过 <code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">start</span></code> 来启动应用。因此，一般来说会这样写 <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM node:slim

RUN mkdir /app
WORKDIR /app
COPY ./package.json /app
RUN [&quot;npm&quot;, &quot;install&quot;]
COPY . /app/
CMD [&quot;npm&quot;, &quot;start&quot;]
</pre></div>
</div>
<p>把这个 <span class="guilabel">Dockerfile</span> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <span class="guilabel">Dockerfile</span> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 <span class="guilabel">Dockerfile</span> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <span class="guilabel">Dockerfile</span> ，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <span class="guilabel">Dockerfile</span> 是复制、黏贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <span class="guilabel">Dockerfile</span>，而第二个项目的 <span class="guilabel">Dockerfile</span> 就会被自动修复。</p>
<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <span class="guilabel">Dockerfile</span> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <span class="guilabel">Dockerfile</span> 就会变为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM node:slim

RUN mkdir /app
WORKDIR /app
CMD [&quot;npm&quot;, &quot;start&quot;]
</pre></div>
</div>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code class="docutils literal notranslate"><span class="pre">my-node</span></code> 的话，各个项目内的自己的 <span class="guilabel">Dockerfile</span> 就变为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM my-node
COPY ./package.json /app
RUN [&quot;npm&quot;, &quot;install&quot;]
COPY . /app
</pre></div>
</div>
<p>基础镜像变化后，各个项目都用这个 <span class="guilabel">Dockerfile</span> 重新构建镜像，会继承基础镜像的更新。</p>
<p>那么，问题解决了吗？没有。准确说，只解决了一半。如果这个 <span class="guilabel">Dockerfile</span> 里面有些东西需要调整呢？比如 <code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">install</span></code> 都需要加一些参数，那怎么办？这一行 <span class="guilabel">RUN</span> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code class="docutils literal notranslate"><span class="pre">./package.json</span></code> ，难道又要一个个修改吗？所以说，这样制作基础镜像，只解决了原来的 <span class="guilabel">Dockerfile</span> 的前四条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>
<p><span class="guilabel">ONBUILD</span> 可以解决这个问题。让我们用 <span class="guilabel">ONBUILD</span> 重新写一下基础镜像的 <span class="guilabel">Dockerfile</span>：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM node:slim

RUN mkdir /app
WORKDIR /app
ONBUILD COPY ./package.json /app
ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]
ONBUILD COPY . /app/
CMD [ &quot;npm&quot;, &quot;start&quot; ]
</pre></div>
</div>
<p>这次我们回到原始的 <span class="guilabel">Dockerfile</span>，但是这次将项目相关的指令加上 <span class="guilabel">ONBUILD</span>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <span class="guilabel">Dockerfile</span> 就变成了简单的：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM my-node
</pre></div>
</div>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <span class="guilabel">Dockerfile</span> 构建镜像时，之前基础镜像的那三行 <span class="guilabel">ONBUILD</span> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对项目执行 <code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">install</span></code> ，生成应用镜像。</p>
</div>
</div>
<div class="section" id="id21">
<h2>多阶段构建<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id22">
<h3>之前的做法<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p>在 <strong>Docker 17.05</strong> 版本之前，我们构建 Docker 镜像时，通产会采用两种方式：</p>
<ul>
<li><p>全部放入一个 Dockerfile</p>
<blockquote>
<div><p>一种方式是将所有的构建过程包含在一个 <span class="guilabel">Dockerfile</span> 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来一些问题：</p>
<ul class="simple">
<li><p><span class="guilabel">Dockerfile</span> 特别长，可维护性降低</p></li>
<li><p>镜像层次多，镜像体积大较大，部署时间长</p></li>
<li><p>源代码存在泄漏的风险</p></li>
</ul>
<p>例如，编写 <code class="docutils literal notranslate"><span class="pre">app.go</span></code> 文件，该程序输出 <code class="docutils literal notranslate"><span class="pre">Hello</span> <span class="pre">World!</span></code></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>package main

import &quot;fmt&quot;

func main() {
    fmt.Printf(&quot;Hello World!&quot;);
}
</pre></div>
</div>
<p>编写 <code class="docutils literal notranslate"><span class="pre">Dockerfile.one</span></code> 文件</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM golang:1.9-alpine

RUN apk --no-cache add git ca-certificates

WORKDIR /go/src/github.com/go/hellworld/

COPY app.go .

RUN go get -d -v github.com/go-sql-driver/mysql \
    &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a installsuffix cgo -o app . \
    &amp;&amp; cp /go/src/github.com/go/helloworld/app /root

WORKDIR /root/

CMD [&quot;./app&quot;]
</pre></div>
</div>
<p>构建镜像</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build --tag go/helloworld:1 --file Dockerfile.one .
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>分散到多个 Dockerfile</p>
<blockquote>
<div><p>另一种方式，就是我们事先在一个 <span class="guilabel">Dockerfile</span> 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 <span class="guilabel">Dockerfile</span> 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p>
<p>例如</p>
<p>编写 <code class="docutils literal notranslate"><span class="pre">Dockerfile.build</span></code> 文件</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM golang:1.9-alpine

RUN apk --no-cache add git

WORKDIR /go/src/github.com/go/helloworld

COPY app.go .

RUN go get -d -v github.com/go-sql-driver/mysql \
    &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .
</pre></div>
</div>
<p>编写 <code class="docutils literal notranslate"><span class="pre">Dockerfile.copy</span></code> 文件</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

COPY app .

CMD [&quot;./app&quot;]
</pre></div>
</div>
<p>新建 <code class="docutils literal notranslate"><span class="pre">build.sh</span></code></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/bin/sh
echo Building go/helloworld:build

docker image build --tag go/helloworld:build . --file Dockerfile.build

docker container create --name extract go/helloworld:build
docker container cp extract:/go/src/github.com/go/helloworld/app ./app
docker container rm --force extract

echo Building go/helloworld:2

docker image build --no-cache --tag go/helloworld:2 . --file Dockerfile.copy
rm ./app
</pre></div>
</div>
<p>现在运行脚本即可构建镜像</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ chmod +x build.sh
$ ./build.sh
</pre></div>
</div>
<p>对别两种方式生成的镜像大小</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image ls
REPOSITORY      TAG IMAGE           ID  CREATED     SIZE
go/helloworld   2   f7cf3465432c    22  seconds ago 6.47MB
go/helloworld   1   f55d3e16affc    2   minutes ago 295MB
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id23">
<h3>使用多阶段构建<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h3>
<p>为解以上的问题，<strong>Docker v17.05</strong> 开始支持多阶段构建（<code class="docutils literal notranslate"><span class="pre">multistage</span> <span class="pre">builds</span></code>）。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 <span class="guilabel">Dockerfile</span> ：</p>
<p>例如</p>
<p>编写 <span class="guilabel">Dockerfile</span> 文件</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM golang:1.9-alpine as builder

RUN apk --no-cache add git

WORKDIR /go/src/github.com/go/helloworld/

RUN go get -d -v github.com/go-sql-driver/mysql

COPY app.go .

RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest as prod

RUN apk --no-cache add ca-certificates

WORKDIR /root/

COPY --from=0 /go/src/github.com/go/helloworld/app .

CMD [&quot;./app&quot;]
</pre></div>
</div>
<p>构建镜像</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build --tag go/helloworld:3 .
</pre></div>
</div>
<p>对比三个镜像的大小</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image ls
REPOSITORY      TAG IMAGE           ID              CREATED SIZE
go/helloworld   3   d6911ed9c846    7 seconds ago   6.47 MB
go/helloworld   2   f7cf3465432c    22 seconds ago  6.47 MB
go/helloworld   1   f55d3e16affc    2 minutes ago   295 MB
</pre></div>
</div>
<p>很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</p>
</div>
<div class="section" id="id24">
<h3>只构建某一阶段的镜像<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p>我们可以使用 <code class="docutils literal notranslate"><span class="pre">as</span></code> 来为某一阶段命令，例如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM golang:1.9-alpine as builder
</pre></div>
</div>
<p>例如当我们只构建 <code class="docutils literal notranslate"><span class="pre">builder</span></code> 阶段的镜像时，我们可以使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令时加上 <code class="docutils literal notranslate"><span class="pre">--target</span></code> 参数即可</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build --target builder --tag username/imagename:tag
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h3>构建时聪其他镜像复制文件<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<p>上面例子中我们使用 <code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">--from=0</span> <span class="pre">/go/src/github.com/go/helloworld/app</span> <span class="pre">.</span></code> 从上一阶段的镜像中复制文件，我们也可以复制任何镜像中的文件。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf
</pre></div>
</div>
</div>
</div>
<div class="section" id="id26">
<h2>Docker Registry<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h2>
<div class="section" id="registry">
<h3>Registry 分类<a class="headerlink" href="#registry" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Registry 用于保存 docker 镜像，包括镜像的层次结构和元数据。</p></li>
<li><p>用户可自建 Registry，也可以使用官方的 Docker Hub</p></li>
<li><p>详细分类</p>
<blockquote>
<div><ul>
<li><p>Sponsor Registry</p>
<blockquote>
<div><p>第三方的 Registry，供客户和 Docker 社区使用</p>
</div></blockquote>
</li>
<li><p>Mirror Registry</p>
<blockquote>
<div><p>第三方的 Registry，只让客户使用</p>
</div></blockquote>
</li>
<li><p>Vendor Registry</p>
<blockquote>
<div><p>由发布 Docker 镜像的供应商提供的 Registry</p>
</div></blockquote>
</li>
<li><p>Private Registry</p>
<blockquote>
<div><p>通过设有防火墙和额外的安全层的私有实体提供的 Registry</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id27">
<h3>私有仓库操作<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人仓库。</p>
<p>创建好私有仓库之后，就可以使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">tag</span></code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code class="docutils literal notranslate"><span class="pre">`127.0.0.1:5000</span></code> 。</p>
<p>先在本机查看已有的镜像。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image ls
REPOSITORY     TAG      IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu         latest   ba5877dc9bec        6 weeks ago         192.7 MB
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">tag</span></code> 将 <code class="docutils literal notranslate"><span class="pre">ubuntu:latest</span></code> 这个镜像标记为 <code class="docutils literal notranslate"><span class="pre">127.0.0.1:5000/ubuntu:latest</span></code> 。
格式为 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">IMAGE[:TAG]</span> <span class="pre">[REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</span></code> 。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest
$ docker image ls
REPOSITORY                        TAG       IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu                            latest    ba5877dc9bec        6 weeks ago         192.7 MB
127.0.0.1:5000/ubuntu:latest      latest    ba5877dc9bec        6 weeks ago         192.7 MB
</pre></div>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">push</span></code> 上传标记的镜像</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker push 127.0.0.1:5000/ubuntu:latest
The push refers to repository [127.0.0.1:5000/ubuntu]
373a30c24545: Pushed
a9148f5200b0: Pushed
cdd3de0940ab: Pushed
fc56279bbb33: Pushed
b38367233d37: Pushed
2aebd096e0e2: Pushed
latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568
</pre></div>
</div>
<p>用 <code class="docutils literal notranslate"><span class="pre">curl</span></code> 查看仓库中的镜像。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ curl 127.0.0.1:5000/v2/_catalog
{&quot;repositories&quot;:[&quot;ubuntu&quot;]}
</pre></div>
</div>
<p>这里可以看到 <code class="docutils literal notranslate"><span class="pre">{&quot;repositories&quot;:&quot;[ubuntu]&quot;}</span></code> ，这表明镜像已经被成功上传。</p>
<p>先删除已有镜像，在尝试从私有仓库中下载这个镜像。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image rm 127.0.0.1:5000/ubuntu:latest

$ docker image pull 127.0.0.1:5000/ubuntu:latest
Pulling repository 127.0.0.1:5000/ubuntu:latest
ba5877dc9bec: Download complete
511136ea3c5a: Download complete
9bad880da3d2: Download complete
25f11f5fb0cb: Download complete
ebc34468f71d: Download complete
2318d26665ef: Download complete

$ docker image ls
REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h3>注意事项<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>如果你不想使用 <code class="docutils literal notranslate"><span class="pre">127.0.0.1:5000</span></code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code class="docutils literal notranslate"><span class="pre">192.168.199.100:5000</span></code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p>
<p>这是因为 Docker 默认 不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制。</p>
<p>对于使用 <code class="docutils literal notranslate"><span class="pre">systemd</span></code> 的系统，请在 <code class="docutils literal notranslate"><span class="pre">/etc/docker/daemon.json</span></code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;registry-mirror&quot;: [
        &quot;https://registry.docker-cn.com&quot;
    ],
    &quot;insecure-registries&quot;: [
        &quot;192.168.199.100:5000&quot;
    ]
}
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>该文件必须符合 json 规范，否则 Docker 将不能启动。</p>
</div>
</div>
</div>
<div class="section" id="id29">
<h2>资源限制<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h2>
<p>在使用 docker 运行容器时，一台主机上可能会运行几百个容器，这些容器虽然互相隔离，但是底层却使用着相同的 CPU、内存和磁盘资源。如果不对容器使用的资源进行限制，那么容器之间会相互影响，小的来说会导致容器资源使用不公平；大的来说，可能会导致主机和集群资源耗尽，服务完全不可用。</p>
<p>docker 作为容器的管理者，自然提供了控制容器资源的功能。正如使用内核的 namespace 来做容器之间的隔离，docker 也是通过内核的 cgroup 来做容器的资源限制。这篇文章就介绍如何使用 docker 来限制 CPU、内存和IO，以及对应的 cgroups 文件。</p>
<p>我们本地测试的 docker 版本是 <code class="docutils literal notranslate"><span class="pre">18.06.1-ce</span></code>，操作系统是 <code class="docutils literal notranslate"><span class="pre">CentOS</span> <span class="pre">7.4.1708</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>不同版本和系统的功能会有差异，具体的使用方法和功能请以具体版本的 docker 官方文档为准。</p>
</div>
<p>我们使用 <a class="reference external" href="https://github.com/progrium/docker-stress">stress</a> 容器来产生 CPU、内存和 IO 的压力，具体的使用请参考它的帮助文档。</p>
<div class="section" id="cpu">
<h3>CPU 资源<a class="headerlink" href="#cpu" title="Permalink to this headline">¶</a></h3>
<p>主机上的进程会通过时间分片机制使用 CPU，CPU 的量化单位是频率，也就是每秒钟能执行的运算次数。为容器限制 CPU 资源并不能改变 CPU 的运行频率，而是改变每个容器能使用的 CPU 时间片。理想状态下，CPU 应该一直处于运行状态（并且进程需要的计算量不会超过 CPU 的处理能力）。</p>
<ul>
<li><p>docker 限制 CPU Share</p>
<blockquote>
<div><p>docker 允许用户为每个容器设置一个数字，代表容器的 CPU Share，默认情况下每个容器的 share 是 1024。要注意，这个shere是相对的，本身并不能代表任何确定的意义。当主机上有多个容器运行时，每个容器占用的 CPU 时间比例为它的 share 在总额中的比例。举个例子，如果主机上有两个一直使用 CPU 的容器（为了简化理解，不考虑主机上其他进程），如果主机上有两个一直使用 CPU 的容器（为了简化理解，不考虑主机上其他进程），其 CPU Share 都是 1024，那么两个容器 CPU 使用率都是 50%；如果把其中一个容器的 share 设置为 512，那么两者 CPU 的使用率分别为 67% 和 33%；如果删除 share 为 1024 的容器，剩下来容器的 CPU 使用率将会是 100%。</p>
<p>总结下来，这种情况下，docker 会根据主机上运行的容器和进程动态调整每个容器使用 CPU 的时间比例。这样的好处是能保证 CPU 尽可能处于运行状态，充分利用 CPU 资源，而且保证所有容器的相对公平；缺点是无法指定容器使用 CPU 的确定值。</p>
<p>docker 为容器设置 CPU share 的参数是 <code class="docutils literal notranslate"><span class="pre">-c</span> <span class="pre">--cpu-shares</span></code> ，它的值是一个整数。</p>
<p>我的主机是 2 核心的 CPU，因此使用 <code class="docutils literal notranslate"><span class="pre">stress</span></code> 启动 4 个进程来产生计算压力：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker container run --rm --interactive --tty progrium/stress --cpu 2
stress: info: [1] dispatching hogs: 2 cpu, 0 io, 0 vm, 0 hdd
stress: dbug: [1] using backoff sleep of 6000us
stress: dbug: [1] --&gt; hogcpu worker 2 [6] forked
stress: dbug: [1] using backoff sleep of 3000us
stress: dbug: [1] --&gt; hogcpu worker 1 [7] forked
</pre></div>
</div>
<p>在另外一个 terminal 使用 <code class="docutils literal notranslate"><span class="pre">htop</span></code> 查看资源的使用情况：</p>
<img alt="../../_images/htop_01.png" src="../../_images/htop_01.png" />
<p>从上图中可以看到，CPU 2个核心资源都达到了 100%。如果两个 stress 进程 CPU 使用率没有达到 100% 是因为系统中还有其他容器在运行。</p>
<p>为了比较，另外启动一个 share 为  512 的容器：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker container run --rm --interactive --tty --cpu-shares 1024 --detach progrium/stress --cpu 2
56b5a33cbd21c3d02af582034e7bf8edf66f97a2c9daec8390d101ab60e8842e
$ docker container run --rm --interactive --tty --cpu-shares 512 --detach progrium/stress --cpu 2
499e280058fc8280583c8833aaf9b07b0ca4e0e74a87f2dafd12bd970cca0625
</pre></div>
</div>
<p>因为默认情况，容器的 CPU share 为 1024，所以这两个容器的 CPU 使用率应该大致为 2:1，下面时启动第二个容器之后的监控截图：</p>
<img alt="../../_images/htop_02.png" src="../../_images/htop_02.png" />
<p>两个容器分别启动了两个 <code class="docutils literal notranslate"><span class="pre">stress</span></code> 进程，第一个容器 <code class="docutils literal notranslate"><span class="pre">stress</span></code> 进程 CPU 使用率都在 66% 左右，第二个容器 <code class="docutils literal notranslate"><span class="pre">stress</span></code> 进程 CPU 使用率在 33% 左右，比例关系大致为 2:1，符合之前的预期。</p>
</div></blockquote>
</li>
<li><p>限制容器能使用的 CPU 核心数</p>
<blockquote>
<div><p>上面讲述的 <code class="docutils literal notranslate"><span class="pre">-c</span> <span class="pre">--cpu-shares</span></code> 参数只能限制容器使用 CPU 的比例，或者说优先级，无法确定地限制容器使用 CPU 的具体核心数；从 1.13 版本之后，docker 提供了 <code class="docutils literal notranslate"><span class="pre">--cpus</span></code> 参数可以限定容器能使用的 CPU 核心数。这个功能可以让我们更精确的设置容器 CPU 使用量，是一种更容易理解也因此更常用的手段。</p>
<p><code class="docutils literal notranslate"><span class="pre">--cpus</span></code> 后面跟着一个浮点数，代表容器最多使用的核心数，可以精确到小数点两位，也就是说容器最小可以使用 <code class="docutils literal notranslate"><span class="pre">0.01</span></code> 核心的 CPU。比如，我们可以限制容器智能使用 <code class="docutils literal notranslate"><span class="pre">1.0</span></code> 核心数的 CPU：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># docker container run --rm --interactive --tty --cpus 1.0 progrium/stress --cpu 2
stress: info: [1] dispatching hogs: 2 cpu, 0 io, 0 vm, 0 hdd
stress: dbug: [1] using backoff sleep of 6000us
stress: dbug: [1] --&gt; hogcpu worker 2 [6] forked
stress: dbug: [1] using backoff sleep of 3000us
stress: dbug: [1] --&gt; hogcpu worker 1 [7] forked
</pre></div>
</div>
<p>在容器里启动两个 stress 来跑 CPU 压力，如果不加限制，这个容器会导致 CPU 的使用率为 %200 左右（也就是说会占用两个核心的计算能力）。实际的监控如下图：</p>
<img alt="../../_images/htop_03.png" src="../../_images/htop_03.png" />
<p>可以看到，每个 <code class="docutils literal notranslate"><span class="pre">stress</span></code> 进程 CPU 使用率大约在 50%，总共的使用率为 100%，符合一颗核心的设置。</p>
<p>如果设置的 <code class="docutils literal notranslate"><span class="pre">--cpus</span></code> 值大于主机的 CPU 核心数，docker 会直接报错：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># docker container run --rm --interactive --tty --cpus 4 progrium/stress --cpu 2
docker: Error response from daemon: Range of CPUs is from 0.01 to 2.00, as there are only 2 CPUs available.
See &#39;docker run --help&#39;.
</pre></div>
</div>
<p>如果多个容器都设置了 <code class="docutils literal notranslate"><span class="pre">--cpus</span></code> ，并且它们之和超过主机的CPU核心数，并不会导致容器失败或者退出，这些容器之间回竞争使用CPU，具体配置分配的 CPU 数量取决于主机运行情况和容器的 CPU Share 值。也就是说 <code class="docutils literal notranslate"><span class="pre">--cpus</span></code> 只能保证在 CPU 资源充足的情况下容器最多能使用的 CPU 数，docker 并不能保证在任何情况下容器都能使用这么多的 CPU（因为这根本是不可能的）。</p>
</div></blockquote>
</li>
<li><p>限制容器运行在某些 CPU 核心</p>
<blockquote>
<div><p>现在的笔记本和服务器都会有多个 CPU，docker 也允许调度的时候限定容器运行在哪个 CPU 上。比如，我的主机上有2个核心，可以通过 <code class="docutils literal notranslate"><span class="pre">--cpuset-cpus</span></code> 参数让容器只运行在前两个核心上：</p>
<img alt="../../_images/htop_04.png" src="../../_images/htop_04.png" />
<p><code class="docutils literal notranslate"><span class="pre">--cpuset-cpus</span></code> 参数可以和 <code class="docutils literal notranslate"><span class="pre">-c</span> <span class="pre">--cpu-shares</span></code> 一起使用，限制容器只能运行在某些 CPU 核心上，并且配置了使用率。</p>
<p>限制容器运行在哪些核心上并不是一个很好的做法，因为它需要事先知道主机上有多少 CPU 核心，而且非常不灵活。除非有特别的需求，一般并不推荐在生产中这样使用。</p>
</div></blockquote>
</li>
<li><p>CPU 信息的 cgroup 文件</p>
<blockquote>
<div><p>所有和容器 CPU share 有关的配置都保存在 <code class="docutils literal notranslate"><span class="pre">/sys/fs/cgroup/cpu/docker/&lt;docker_id&gt;/</span></code> 目录下面，其中 <code class="docutils literal notranslate"><span class="pre">cpu.shares</span></code> 保存了 CPU share 的值（其他文件的意义可以查看 cgroups 的官方文档）：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ls /sys/fs/cgroup/cpu/docker/94e9747a84da1dbe0783b183a65d56308fa97534e102a6ba7aa4bf8193680a5e/
cgroup.clone_children  cgroup.procs  cpuacct.usage         cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release
cgroup.event_control   cpuacct.stat  cpuacct.usage_percpu  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks
</pre></div>
</div>
<p>和 cpuset（限制 CPU 核心）有关的文件在 <code class="docutils literal notranslate"><span class="pre">/sys/fs/cgroup/cpuset/docker/&lt;docker_id&gt;</span></code> 目录下，其中 <code class="docutils literal notranslate"><span class="pre">cpuset.cpus</span></code> 保存了当前容器能使用的 CPU 核心。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ls /sys/fs/cgroup/cpuset/docker/94e9747a84da1dbe0783b183a65d56308fa97534e102a6ba7aa4bf8193680a5e/
cgroup.clone_children  cpuset.cpu_exclusive  cpuset.mem_hardwall     cpuset.memory_spread_page  cpuset.sched_load_balance        tasks
cgroup.event_control   cpuset.cpus           cpuset.memory_migrate   cpuset.memory_spread_slab  cpuset.sched_relax_domain_level
cgroup.procs           cpuset.mem_exclusive  cpuset.memory_pressure  cpuset.mems                notify_on_release
# cat /sys/fs/cgroup/cpuset/docker/94e9747a84da1dbe0783b183a65d56308fa97534e102a6ba7aa4bf8193680a5e/cpuset.cpus
0-1
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">--cpus</span></code> 限制 CPU 核心数并不像上面两个参数一样有对应的文件，它是由 <code class="docutils literal notranslate"><span class="pre">cpu.cfs_period_us</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cpu.cfs_quota_us</span></code> 两个文件控制的。如果容器的 <code class="docutils literal notranslate"><span class="pre">--cpus</span></code> 设置为 3，其对应的这两个文件值为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>~ cat /sys/fs/cgroup/cpu/docker/233a38cc641f2e4a1bec3434d88744517a2214aff9d8297e908fa13b9aa12e02/cpu.cfs_period_us
100000
~ cat /sys/fs/cgroup/cpu/docker/233a38cc641f2e4a1bec3434d88744517a2214aff9d8297e908fa13b9aa12e02/cpu.cfs_quota_us
300000
</pre></div>
</div>
<p>其实在 1.12 以及之前的版本，都是通过 <code class="docutils literal notranslate"><span class="pre">--cpu-period</span></code> 和 <code class="docutils literal notranslate"><span class="pre">--cpu-quota</span></code> 这两个参数控制容器能使用的 CPU 核心数的。前者表示 CPU 的周期数，默认是 100000，单位是微秒，也就是 1s，一般不需要修改；后者表示容器在上述的 CPU 周期里能使用的 quota，真正能使用的 CPU 核心数就是 <code class="docutils literal notranslate"><span class="pre">cpu-quota/cpu-period</span></code> ，因此对于 3 核心的容器，对应的 <code class="docutils literal notranslate"><span class="pre">cpu-quota</span></code> 值为 <code class="docutils literal notranslate"><span class="pre">300000</span></code> 。</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id30">
<h3>内存资源<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<p><strong>默认情况下，docker 并没有对容器内存进行限制</strong>，也就是说容器可以使用主机提供的所有内存。者当然是非常危险的事情，如果某个容器运行了恶意的内存消耗软件，或者代码由内存泄漏，很可能回导致主机内存耗尽，因此导致服务不可用。对于这种情况，docker 会设置 docker daemon 的 OOM (out of memory) 值，使其在内存不足的时候被杀死的优先级降低。另外，就是你可以为每个容器设置内存使用的上限，一旦超过这个上限，容器会被杀死，而不是耗尽主机的内存。</p>
<p>限制内存上限虽然能保护主机，到那时也可能会伤害到容器里的服务。如果为服务设置的内存上限太小，会导致服务还在正常工作的时候就被 OOM 杀死；如果设置的过大，会因为调度器算法浪费内存。因此，合理的做法包括：</p>
<blockquote>
<div><ul class="simple">
<li><p>为应用做内存压力测试，理解正常业务需求下使用的内存情况，然后才能进入生产环境使用</p></li>
<li><p>一定要限制容器的内存使用上限</p></li>
<li><p>尽量保证主机的资源充足，一旦通过监控发现资源不足，就进行扩容或者对容器进行迁移</p></li>
<li><p>如果可以（内存资源充足的情况），尽量不要使用 swap，swap 的使用会导致内存计算复杂，对调度器非常不友好</p></li>
</ul>
</div></blockquote>
<ul>
<li><p>docker 限制容器的内存使用量</p>
<blockquote>
<div><p>在 docker 启动参数中，和内存限制有关的包括（参数的值一般是内存大小，也就是一个正数，后面跟着内存单位 <span class="guilabel">b</span>:guilabel:<cite>k</cite>:guilabel:<cite>m</cite>:guilabel:<cite>g</cite>，分别对应 bytesKBMBGB）：</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-m</span> <span class="pre">--memory</span></code> : 容器能使用的最大内存大小，最小值为 4m</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--memory-swap</span></code> : 容器能够使用的 swap 大小</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--memory-swappiness</span></code> : 默认情况下，主机可以把容器使用的匿名页（anonymous page）swap 出来，你可以设置一个 0-100 之间的值，代表允许 swap 出来的比例</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--memory-reservation</span></code> : 设置一个内存使用的 soft limit，如果 docker 发现主机内存不足，会执行 OOM 操作。这个值必须小于 <code class="docutils literal notranslate"><span class="pre">--memory</span></code> 设置的值</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--kernel-memory</span></code> : 容器能够使用 kernel memory 大小，最小值为 4m。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--oom-kill-disable</span></code> : 是否运行 OOM 的时候杀死容器。只有设置了 <code class="docutils literal notranslate"><span class="pre">-m</span></code> 才可以把这个选项设置为 false，否则容器会耗尽主机内存，而且导致主机应用被杀死。</p></li>
</ul>
</div></blockquote>
<p>关于 <code class="docutils literal notranslate"><span class="pre">--memory-swap</span></code> 的设置必须解释一下， <code class="docutils literal notranslate"><span class="pre">--memory-swap</span></code> 必须在 <code class="docutils literal notranslate"><span class="pre">--memory</span></code> 也配置的情况下才能有用。</p>
<blockquote>
<div><ul class="simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">--memory-swap</span></code> 的值大于 <code class="docutils literal notranslate"><span class="pre">--memory</span></code> ，那么容器能使用的总内存（内存+swap）为 <code class="docutils literal notranslate"><span class="pre">--memory-swap</span></code> 的值，能使用的 swap 值为 <code class="docutils literal notranslate"><span class="pre">--memory-swap</span></code> 减去 <code class="docutils literal notranslate"><span class="pre">--memory</span></code> 的值。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">--memory-swap</span></code> 为 0，或者和 <code class="docutils literal notranslate"><span class="pre">--memory</span></code> 的值相同，那么容器能使用两倍于内存的 swap 大小，如果 <code class="docutils literal notranslate"><span class="pre">--memory</span></code> 对应的值是 <code class="docutils literal notranslate"><span class="pre">200M</span></code> ，那么容器可以使用 <code class="docutils literal notranslate"><span class="pre">400m</span></code> swap。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">--memory-swap</span></code> 的值为 -1，那么不限制 swap 的使用，也就是说主机有多少 swap，容器都可以使用。</p></li>
</ul>
</div></blockquote>
<p>如果限制容器的内存使用为 64M，在申请 64M 资源的情况下，容器运行正常（如果主机上内存非常紧张，并不一定能保证这一点），因为单位换算率的差异，容器里的进程被 KILL 掉了：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker --host tcp://cicd.renkeju.com:2376 container run --rm --interactive --tty --memory 64m progrium/stress:latest --vm 1 --vm-bytes 64M --vm-hang 0
stress: info: [1] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd
stress: dbug: [1] using backoff sleep of 3000us
stress: dbug: [1] --&gt; hogvm worker 1 [6] forked
stress: dbug: [6] allocating 67108864 bytes ...
stress: dbug: [6] touching bytes in strides of 4096 bytes ...
stress: FAIL: [1] (416) &lt;-- worker 6 got signal 9
stress: WARN: [1] (418) now reaping child worker processes
stress: FAIL: [1] (422) kill error: No such process
stress: FAIL: [1] (452) failed run completed in 0s
</pre></div>
</div>
<p>如果申请 100M 内存，会发现容器里的进程被 KILL 掉了（worker 6 got signal 9，signal 9 就是 kill 信号）</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker --host tcp://cicd.renkeju.com:2376 container run --rm --interactive --tty --memory 64m progrium/stress:latest --vm 1 --vm-bytes 100M --vm-hang 0
stress: info: [1] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd
stress: dbug: [1] using backoff sleep of 3000us
stress: dbug: [1] --&gt; hogvm worker 1 [6] forked
stress: dbug: [6] allocating 104857600 bytes ...
stress: dbug: [6] touching bytes in strides of 4096 bytes ...
stress: FAIL: [1] (416) &lt;-- worker 6 got signal 9
stress: WARN: [1] (418) now reaping child worker processes
stress: FAIL: [1] (422) kill error: No such process
stress: FAIL: [1] (452) failed run completed in 0s
</pre></div>
</div>
<p>关于 swap 和 kernel memory 的限制就不在这里过多解释了，感兴趣的可以查看官方的文档。</p>
</div></blockquote>
</li>
<li><p>内存信息的 cgroups 文件</p>
<blockquote>
<div><p>对于 docker 来说，它的内存限制也是存放在 cgroups 文件系统的。对于某个容器，你可以在 <code class="docutils literal notranslate"><span class="pre">/sys/fs/cgroups/memory/docker/&lt;container_id&gt;</span></code> 目录下看到容器内存相关的文件：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ls /sys/fs/cgroup/memory/docker/94e9747a84da1dbe0783b183a65d56308fa97534e102a6ba7aa4bf8193680a5e/
cgroup.clone_children           memory.kmem.tcp.max_usage_in_bytes  memory.oom_control
cgroup.event_control            memory.kmem.tcp.usage_in_bytes      memory.pressure_level
cgroup.procs                    memory.kmem.usage_in_bytes          memory.soft_limit_in_bytes
memory.failcnt                  memory.limit_in_bytes               memory.stat
memory.force_empty              memory.max_usage_in_bytes           memory.swappiness
memory.kmem.failcnt             memory.memsw.failcnt                memory.usage_in_bytes
memory.kmem.limit_in_bytes      memory.memsw.limit_in_bytes         memory.use_hierarchy
memory.kmem.max_usage_in_bytes  memory.memsw.max_usage_in_bytes     notify_on_release
memory.kmem.slabinfo            memory.memsw.usage_in_bytes         tasks
memory.kmem.tcp.failcnt         memory.move_charge_at_immigrate
memory.kmem.tcp.limit_in_bytes  memory.numa_stat
</pre></div>
</div>
<p>而上面的内存限制对应的文件是 <code class="docutils literal notranslate"><span class="pre">memory.limit_in_bytes</span></code> ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /sys/fs/cgroup/memory/docker/94e9747a84da1dbe0783b183a65d56308fa97534e102a6ba7aa4bf8193680a5e/memory.limit_in_bytes
9223372036854771712
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="io">
<h3>IO 资源（磁盘）<a class="headerlink" href="#io" title="Permalink to this headline">¶</a></h3>
<p>对于磁盘来说，考量的参数是容量和读写速度，因此对容器的磁盘限制也应该从这两个维度出发。目前 docker 支持对磁盘的读写速度进行限制，但是并没有方法能限制容器能使用的磁盘容量（一旦磁盘 mount 到容器里，容器就能够使用磁盘的所有容量）。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container run --interactive --tty --rm ubuntu:16.04 bash
root@faeb980ed4d5:/# time $(dd if=/dev/zero of=/tmp/test.data bs=10M count=100 &amp;&amp; sync)
100+0 records in
100+0 records out
1048576000 bytes (1.0 GB, 1000 MiB) copied, 1.62132 s, 647 MB/s

real        0m3.000s
user        0m0.000s
sys 0m1.580s
root@faeb980ed4d5:/#
</pre></div>
</div>
<ul>
<li><p>限制磁盘的权重</p>
<blockquote>
<div><p>通过 <code class="docutils literal notranslate"><span class="pre">--blkio-weight</span></code> 参数可以设置 block 的权重，这个权重和 <code class="docutils literal notranslate"><span class="pre">--cpu-shares</span></code> 类似，它是一个相对值，取值范围是 10-1000，当多个 block 去写磁盘的时候，其读写速度和权重成反比。</p>
<p>不过在我的环境中， <code class="docutils literal notranslate"><span class="pre">--blkio-weight</span></code> 参数虽然设置了对应的 cgroups 值，但是并没有作用，不同的 weight 容器的读写速度还是一样的。github 上有一个对应的 <a class="reference external" href="https://github.com/moby/moby/issues/16173">issue</a> ，但是没有详细的解答。</p>
<p><code class="docutils literal notranslate"><span class="pre">--blkio-weight-device</span></code> 可以设置某个设备的权重值，测试下来虽然两个容器同时读的速度不同，但是并没有按照对应的比例来限制。</p>
</div></blockquote>
</li>
<li><p>限制磁盘的读写速率</p>
<blockquote>
<div><p>除了权重之外，docker 还允许你直接限制磁盘的读写速率，对应的参数有：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">--device-read-bps</span></code> 磁盘每秒最多就可以读多少比特 (bytes)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--device-write-bps</span></code> 磁盘美妙最多可以写多少比特 (bytes)</p></li>
</ul>
<p>上面两个参数的值都是磁盘以及对应的速率，格式为 <code class="docutils literal notranslate"><span class="pre">&lt;device-path&gt;:&lt;limit&gt;[unit]</span></code> ， <code class="docutils literal notranslate"><span class="pre">device-path</span></code> 标示磁盘所在的位置，限制 <code class="docutils literal notranslate"><span class="pre">limit</span></code> 为正整数，单位可以是 <code class="docutils literal notranslate"><span class="pre">kb</span></code> 、 <code class="docutils literal notranslate"><span class="pre">mb</span></code> 和 <code class="docutils literal notranslate"><span class="pre">gb</span></code> 。</p>
<p>比如可以把设备的读速率限制在 1mb</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker run -it --device /dev/sda:/dev/sda --device-read-bps /dev/sda:1mb ubuntu:16.04 bash
root@6c048edef769:/# cat /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
8:0 1048576
root@6c048edef769:/# dd iflag=direct,nonblock if=/dev/sda of=/dev/null bs=5M count=10
10+0 records in
10+0 records out
52428800 bytes (52 MB) copied, 50.0154 s, 1.0 MB/s
</pre></div>
</div>
<p>从磁盘中读取 50m 花费了 50s 左右，说明磁盘速率限制起了作用。</p>
<p>另外两个参数可以限制磁盘读写频率（每秒能执行多少读写操作）：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">--device-read-iops</span></code> 磁盘每秒最多可以执行多少 IO 读操作</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--device-write-iops</span></code> 磁盘每秒最多可以执行多少 IO 写操作</p></li>
</ul>
<p>上面两个参数的值都是磁盘以及对应的 IO 上限，格式为 <code class="docutils literal notranslate"><span class="pre">&lt;device-path&gt;:&lt;limit&gt;</span></code> ，limit 为正整数，表示磁盘 IO 上限数量。</p>
<p>比如，我们可以让磁盘每秒最多读 100 次 ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker run -it --device /dev/sda:/dev/sda --device-read-iops /dev/sda:100 ubuntu:16.04 bash
root@2e3026e9ccd2:/# dd iflag=direct,nonblock if=/dev/sda of=/dev/null bs=1k count=1000
1000+0 records in
1000+0 records out
1024000 bytes (1.0 MB) copied, 9.9159 s, 103 kB/s
</pre></div>
</div>
<p>从测试中可以看出，容器设置了读操作的 iops 为 100，在容器内部从 block 中读取 1m 数据（每次 1k,一共要读 1000次），共计耗时约 10s，换算起来就是 100 iops/s，符合预期结果。</p>
<p>写操作 bps 和 iops 读类似，这里就不再重复了，感兴趣可以自己实验。</p>
</div></blockquote>
</li>
<li><p>磁盘信息的 cgroups 文件</p>
<blockquote>
<div><p>容器中磁盘限制的 cgroups 文件为于 <code class="docutils literal notranslate"><span class="pre">/sys/fs/cgroup/blkio/docker/&lt;docker_id&gt;</span></code> 目录：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> $ ls /sys/fs/cgroup/blkio/docker/1402c1682cba743b4d80f638da3d4272b2ebdb6dc6c2111acfe9c7f7aeb72917/
blkio.io_merged                   blkio.io_serviced                blkio.leaf_weight                blkio.throttle.io_serviced        blkio.time_recursive   tasks
blkio.io_merged_recursive         blkio.io_serviced_recursive      blkio.leaf_weight_device         blkio.throttle.read_bps_device    blkio.weight
blkio.io_queued                   blkio.io_service_time            blkio.reset_stats                blkio.throttle.read_iops_device   blkio.weight_device
blkio.io_queued_recursive         blkio.io_service_time_recursive  blkio.sectors                    blkio.throttle.write_bps_device   cgroup.clone_children
blkio.io_service_bytes            blkio.io_wait_time               blkio.sectors_recursive          blkio.throttle.write_iops_device  cgroup.procs
blkio.io_service_bytes_recursive  blkio.io_wait_time_recursive     blkio.throttle.io_service_bytes  blkio.time                        notify_on_release
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">blkio.throttle.read_iops_device</span></code> 对应了设备的读 IOPS，前面一列是设备的编号，可以通过 <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/proc/partitions</span></code> 查看设备和分区的设备号；后面是 IOPS 上限值：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat /sys/fs/cgroup/blkio/docker/1402c1682cba743b4d80f638da3d4272b2ebdb6dc6c2111acfe9c7f7aeb72917/blkio.throttle.read_iops_device
8:0 100
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">blkio.throttle.read_bps_device</span></code> 对应了设备的读速率，格式和 IOPS 类似，只是第二列的值为 bps ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat /sys/fs/cgroup/blkio/docker/9de94493f1ab4437d9c2c42fab818f12c7e82dddc576f356c555a2db7bc61e21/blkio.throttle.read_bps_device
8:0 1048576
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id31">
<h3>总结<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<p>从上面的实验可以看出来，CPU 和内存的资源限制已经是比较成熟和易用，能够满足大部分用户的需求。磁盘限制也是不错的，虽然现在无法动态地限制容量，但是限制磁盘读写速度也能应对很多场景。</p>
<p>至于网络，docker 现在并没有给出网络限制的方案，也不会在可见的未来做这件事情，因为目前网络是通过插件来实现的，和容器本身的功能相对独立，不是很容易实现，扩展性也很差。docker 社区已经有很多呼声，也有 issue 是关于网络流量限制的: <a class="reference external" href="https://github.com/moby/moby/issues/26767">issue 26767</a>、<a class="reference external" href="https://github.com/moby/moby/issues/37">issue 37</a>、<a class="reference external" href="https://github.com/moby/moby/issues/4763">issue 4763</a>。</p>
<p>资源限制一方面可以让我们为容器（应用）设置合理的 CPU、内存等资源，方便管理；另外一方面也能有效地预防恶意的攻击和异常，对容器来说是非常重要的功能。如果你需要在生产环境使用容器，请务必要花时间去做这件事情。</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Docker</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../container.html">容器</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Renkeju.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/container/docker/docker.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>