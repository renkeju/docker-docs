
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Dockerfile &#8212; Docker alphe documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="dockerfile">
<h1>Dockerfile<a class="headerlink" href="#dockerfile" title="Permalink to this headline">¶</a></h1>
<p>从上一小节的 volume 的介绍中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令（Instruction），每一条指令构建一层 ，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>我们以定制 Nginx 镜像为例，我们使用 Dockerfile 来定制。在一个空白目录中，建立一个文本文件，并命名为 <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ mkdir mynginx
$ <span class="nb">cd</span> mynginx
$ touch Dockerfile
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM nginx
RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
</pre></div>
</div>
<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<span class="guilabel">FROM</span> 和 <span class="guilabel">RUN</span> 。</p>
<div class="section" id="from">
<h2>FROM 指定基础镜像<a class="headerlink" href="#from" title="Permalink to this headline">¶</a></h2>
<p>所谓制定镜像，那一定是以一个镜像为基础，在其上进行定制。就像运行了一个 <span class="guilabel">nginx</span>，再进行修改一样，基础镜像是必须指定的。而 <span class="guilabel">RROM</span> 就是指定基础镜像，因此一个 <span class="guilabel">Dockerfile</span> 中 <span class="guilabel">FROM</span> 是必备的指令，并且必须是第一条指令。</p>
<p>在 <a class="reference external" href="https://store.docker.com/">Docker Store</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a class="reference external" href="https://store.docker.com/images/nginx">nginx</a>/<a class="reference external" href="https://store.docker.com/images/redis">redis</a>/<a class="reference external" href="https://store.docker.com/images/mongo">mongo</a>/<a class="reference external" href="https://store.docker.com/images/mysql">mysql</a>/<a class="reference external" href="https://store.docker.com/images/httpd">httpd</a>/<a class="reference external" href="https://store.docker.com/images/php">php</a> <a class="reference external" href="https://store.docker.com/images/tomcat">tomcat</a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a class="reference external" href="https://store.docker.com/images/node">node</a>/<a class="reference external" href="https://store.docker.com/images/openjdk">openjdk</a>/<a class="reference external" href="https://store.docker.com/images/python">python</a>/<a class="reference external" href="https://store.docker.com/images/ruby">ruby</a>/<a class="reference external" href="https://store.docker.com/images/golang">golang</a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a class="reference external" href="https://store.docker.com/images/ubuntu">ubuntu</a>/<a class="reference external" href="https://store.docker.com/images/debian">debian</a>/<a class="reference external" href="https://store.docker.com/images/centos">centos</a>/<a class="reference external" href="https://store.docker.com/images/fedora">fedora</a>/<a class="reference external" href="https://store.docker.com/images/alpine">alpine</a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有的镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <span class="guilabel">scratch</span> 。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM scratch
...
</pre></div>
</div>
<p>如果你以 <span class="guilabel">scratch</span> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像的第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <span class="guilabel">swarm</span> <span class="guilabel">coreos/etcd</span> 。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code class="docutils literal notranslate"><span class="pre">FROM</span> <span class="pre">scratch</span></code> 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
</div>
<div class="section" id="run">
<h2>RUN 执行命令<a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h2>
<p><span class="guilabel">RUN</span> 指令是用来执行命令行命令的。由于命令行的强大能力，<span class="guilabel">RUN</span> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><p><strong>shell</strong> 格式：<code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">&lt;command&gt;</span></code> 就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <span class="guilabel">RUN</span> 指令就是这种格式。</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>exec</strong> 格式： <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">[&quot;executable</span> <span class="pre">file&quot;,</span> <span class="pre">&quot;arg1&quot;,</span> <span class="pre">&quot;arg2&quot;]</span></code> 这更像是函数中调用的格式。</p></li>
</ul>
<p>既然 <span class="guilabel">RUN</span> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 <span class="guilabel">RUN</span> ? 比如这样：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM debian:jessie

RUN apt-get update
RUN apt-get install -y gcc lib6-dev make
RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;
RUN mkdir -p /usr/src/redis
RUN tar -zxf redis.tar.gz -C /usr/src/redis --strip-components=1
RUN make -C /usr/src/redis
RUN make -C /usr/src/redis install
</pre></div>
</div>
<p>之前说过，Dockerfile 中每一个指令都会建立一层，<span class="guilabel">RUN</span> 也不例外。每一个 <span class="guilabel">RUN</span> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后， <code class="docutils literal notranslate"><span class="pre">commit</span></code> 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了7层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加构建部署的时间，也很容易出错。这是很多 Docker 初学者常犯的一个错误。</p>
<p>Union FS 是有**最大层数限制**的，比如 AUFS，之前是最大不得超过 42 层，现在是不得超过 127 层。
上面的 <span class="guilabel">Dockerfile</span> 正确的写法应该是这样的：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM debian:jessie

RUN buildDeps=&#39;gcc libec6-dev make&#39; \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y $buildDeps \
    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \
    &amp;&amp; mkdir -p /usr/src/redis \
    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    &amp;&amp; make -C /usr/src/redis \
    &amp;&amp; make -C /usr/src/redis install \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r /usr/src/redis \
    &amp;&amp; apt-get purge -y --auto-remove $buildDeps
</pre></div>
</div>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用多个 <code class="docutils literal notranslate"><span class="pre">RUN</span></code> 一一对应不同的命令，而是仅仅使用一个 <code class="docutils literal notranslate"><span class="pre">RUN``指令，并使用</span> <span class="pre">``&amp;&amp;</span></code> 将各个所需命令串联起来。将之前的 7 层，简化为 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code class="docutils literal notranslate"><span class="pre">\</span></code> 的换行符命令方式，以及行首 <code class="docutils literal notranslate"><span class="pre">#</span></code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <span class="guilabel">apt</span> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>Docker 初学者制作的 Docker 镜像非常臃肿的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
</div>
<div class="section" id="id1">
<h2>构建镜像<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像。</p>
<p>在 <span class="guilabel">Dockerfile</span> 文件所在目录执行：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build -t nginx:v3 .
Sending build context to Docker daemon  2.048kB
Step 1/2 : FROM nginx:1.14-alpine
---&gt; 14d4a58e0d2e
Step 2/2 : RUN echo &#39;&lt;h1&gt;Hello, World!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
---&gt; Running in 56c88dfe6001
Removing intermediate container 56c88dfe6001
---&gt; 4987c2fc5455
Successfully built 4987c2fc5455
Successfully tagged nginx:v3
</pre></div>
</div>
<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <span class="guilabel">Step 2</span> 中，如同我们之前所说的那样，<span class="guilabel">RUN</span> 指令启动了一个容器 <code class="docutils literal notranslate"><span class="pre">14d4a58e0d2e</span></code> ，执行了所要求的命令，并最后提交了这一层 <code class="docutils literal notranslate"><span class="pre">56c88dfe6001</span></code> ，随后删除了所用到的这个容器 <code class="docutils literal notranslate"><span class="pre">14d4a58e0d2e</span></code> 。</p>
<p>这里我们使用了 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code> 命令进行镜像构建，其格式为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker [--host [socket|tcp]] image build [options] &lt;Dockerfile_Context/URL/-&gt;
</pre></div>
</div>
<p>在这里我们指定了最终镜像的名称 <code class="docutils literal notranslate"><span class="pre">--tag</span> <span class="pre">nginx:v3</span></code> ，构建成功后，我们可以运行 <code class="docutils literal notranslate"><span class="pre">nginx:v3</span></code> 镜像。</p>
</div>
<div class="section" id="context">
<h2>镜像构建上下文（Context）<a class="headerlink" href="#context" title="Permalink to this headline">¶</a></h2>
<p>如果注意，会看到 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令最后一个 <code class="docutils literal notranslate"><span class="pre">.</span></code> 。 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示当前目录，而 <span class="guilabel">Dockerfile</span> 就在当前目录，因此不少初学者以为这个路径时在指定 <span class="guilabel">Dockerfile</span> 所在路径，这样理解不准确。如果对应上面的命令格式，你会发现，这是在指定**上下文路径**。为什么时上下文？</p>
<p>首先我们要理解 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如  <code class="docutils literal notranslate"><span class="pre">docker</span></code> 命令这样的客户端工作，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像时在本机执行各种 <code class="docutils literal notranslate"><span class="pre">docker</span></code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <span class="guilabel">RUN</span> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <span class="guilabel">COPY</span> 指令、<span class="guilabel">ADD</span> 指令等。而 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是说 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令得知这个路径后，会将路径下的所有内容打包，然后上穿给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 <span class="guilabel">Dockerfile</span> 中这么写：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>COPY ./package.json /app/
</pre></div>
</div>
<p>这并不是要复制执行 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令所在的目录下的 package.json，也不是复制 <span class="guilabel">Dockerfile</span> 所在目录下的 package.json，而是复制 <strong>上下文（context）</strong> 目录下的 package.json 。</p>
<p>因此，<span class="guilabel">COPY</span> 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问为什么 <code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">../package.json</span> <span class="pre">/app</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">/opt/xxxx</span> <span class="pre">/app</span></code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span> <span class="pre">--tag</span> <span class="pre">nginx:v3</span> <span class="pre">.</span></code> 中这个 <code class="docutils literal notranslate"><span class="pre">.</span></code> ，实际上是在指定上下文的目录，<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 命令会将该目录心爱的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 输出，我们其实已经看到了这个发送上下文的过程：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build -t nginx:v3 .
Sending build context to Docker daemon  2.048kB
</pre></div>
</div>
<p>理解构建上下文对镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">/opt/xxxx</span> <span class="pre">/app</span></code> 不工作后，于是干脆将 <span class="guilabel">Dockerfile</span> 放到了硬盘根目录去构建，结果发现 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 执行后，在发送一个几十GB的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该将 <span class="guilabel">Dockerfile</span> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code class="docutils literal notranslate"><span class="pre">.gitignore</span></code> 一样的语法写一个 <code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code> ，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 <code class="docutils literal notranslate"><span class="pre">.</span></code> 是指定 <span class="guilabel">Dockerfile</span> 所在目录呢？这是因为在默认情况下，如果并不要求必须位于上下文目录中，比如可以用 <code class="docutils literal notranslate"><span class="pre">-f</span> <span class="pre">../Dockerfile.php</span></code> 参数指定某个文件作为 <span class="guilabel">Dockerfile</span>。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 <span class="guilabel">Dockerfile</span>，以及会将其置于镜像构建上下文目录中。</p>
</div>
<div class="section" id="id2">
<h2>其他构建镜像方法<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>直接用 Git repo 进行构建</p>
<blockquote>
<div><p>或许你已经注意到了， <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build https://github.com/jenkinsci/jenkins.git\#jenkins-2.149
Sending build context to Docker daemon   60.3MB
Step 1/17 : FROM maven:3.5.4-jdk-8 as builder
---&gt; 985f3637ded4
Step 2/17 : COPY .mvn/ /jenkins/src/.mvn/
---&gt; Using cache
---&gt; 449d4e56d53e
Step 3/17 : COPY cli/ /jenkins/src/cli/
---&gt; Using cache
---&gt; 841e76c4f7d8
Step 4/17 : COPY core/ /jenkins/src/core/
---&gt; Using cache
---&gt; b6b7d47e8294
Step 5/17 : COPY src/ /jenkins/src/src/
---&gt; Using cache
---&gt; e7a46ef570cf
Step 6/17 : COPY test/ /jenkins/src/test/
---&gt; Using cache
---&gt; e1d52ec3c4ad
Step 7/17 : COPY war/ /jenkins/src/war/
---&gt; Using cache
---&gt; 3e24961339fc
Step 8/17 : COPY *.xml /jenkins/src/
...
</pre></div>
</div>
<p>这行命令指定了构建所需的 Git repo，并且指定默认的 <span class="guilabel">master</span> 分支，构建目录为 <code class="docutils literal notranslate"><span class="pre">/jenkins-2.149/</span></code> ，然后 Docker 就会自己去 <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span></code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
</div></blockquote>
</li>
<li><p>用给定的 tar 压缩包构建</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker image build http://server/context.tar.gz
</pre></div>
</div>
<p>如果给出的 URL 不是 Git repo，而是个 tar 压缩包，那么 docker 引擎会下载这个压缩包，并自动解压缩，以其作为上下文，开始构建。</p>
</div></blockquote>
</li>
<li><p>从标准输入中读取 Dockerfile 进行构建</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker image build - &lt; Dockerfile
// 或者
cat Dockerfile | docker image build -
</pre></div>
</div>
<p>如果标准输入传入的是文本文件，则将其视为 <span class="guilabel">Dockerfile</span> ，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 内容，它没有上下文，因此不可以像其他方法那样将本地文件 <span class="guilabel">COPY</span> 进镜像之类的事情。</p>
</div></blockquote>
</li>
<li><p>从标准输入中读取上下文压缩包进行构建</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker image build - &lt; context.tar.gz
</pre></div>
</div>
<p>如果发现标准输入的文件格式是 <span class="guilabel">gzip</span> <span class="guilabel">bzip2</span> 以及 <span class="guilabel">xz</span> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
</div></blockquote>
</li>
</ul>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Docker</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../container.html">容器</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Renkeju.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/container/docker/dockerfile.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>