

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Dockerfile 指令 &mdash; Docker alphe documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Docker" href="../docker/docker.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Docker
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started/getting_started.html">入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../docker/docker.html">Docker</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Dockerfile 指令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#copy">COPY 复制文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="#add">ADD 更高级的复制文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cmd">CMD 容器启动命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#entrypoint">ENTRYPOINT 入口点</a></li>
<li class="toctree-l2"><a class="reference internal" href="#env">ENV 设置环境变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="#arg">ARG 构建参数</a></li>
<li class="toctree-l2"><a class="reference internal" href="#volume">VOLUME 定义匿名卷</a></li>
<li class="toctree-l2"><a class="reference internal" href="#expose">EXPOSE 声明端口</a></li>
<li class="toctree-l2"><a class="reference internal" href="#workdir">WORKDIR 指定工作目录</a></li>
<li class="toctree-l2"><a class="reference internal" href="#user">USER 指定当前用户</a></li>
<li class="toctree-l2"><a class="reference internal" href="#healthcheck">HEALTHCHECK 健康检查</a></li>
<li class="toctree-l2"><a class="reference internal" href="#onbuild">ONBUILD 为他人做嫁衣裳</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Docker</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Dockerfile 指令</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/dockerfile/dockerfile.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dockerfile">
<h1>Dockerfile 指令<a class="headerlink" href="#dockerfile" title="Permalink to this headline">¶</a></h1>
<p>我们已经介绍了 <span class="guilabel">FROM</span>、<span class="guilabel">RUN</span>，还提及了 <span class="guilabel">COPY</span>、<span class="guilabel">ADD</span>，其实 <span class="guilabel">Dockerfile</span> 功能很强大，它提供了十多个指令。下面我们继续学习其他的指令。</p>
<div class="section" id="copy">
<h2>COPY 复制文件<a class="headerlink" href="#copy" title="Permalink to this headline">¶</a></h2>
<p>格式：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">&lt;source_path&gt;...</span> <span class="pre">&lt;destination_path&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">[&quot;&lt;source_path_01&gt;&quot;,...</span> <span class="pre">&quot;&lt;destination_path&gt;&quot;]</span></code></p></li>
</ul>
<p>和 <span class="guilabel">RUN</span> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p><span class="guilabel">COPY</span> 指令将从构建上下文目录中 <code class="docutils literal notranslate"><span class="pre">&lt;source_path&gt;</span></code> 的文件/目录复制到新的一层的镜像内 <code class="docutils literal notranslate"><span class="pre">&lt;destination_path&gt;</span></code> 位置。比如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>COPY package.json /usr/src/app
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;destination_path&gt;</span></code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <span class="guilabel">WORKDIR</span> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先进行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <span class="guilabel">COPY</span> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
</div>
<div class="section" id="add">
<h2>ADD 更高级的复制文件<a class="headerlink" href="#add" title="Permalink to this headline">¶</a></h2>
<p><span class="guilabel">ADD</span> 指令和 <span class="guilabel">COPY</span> 的格式和性质基本一致。但是在 <span class="guilabel">COPY</span> 基础上增加了一些功能。</p>
<p>比如 <code class="docutils literal notranslate"><span class="pre">&lt;source_path&gt;</span></code> 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code class="docutils literal notranslate"><span class="pre">&lt;destination_path&gt;</span></code> 去。下载后的文件权限自动设置为 <strong>600</strong>，如果这并不是想要的权限，那么还需要增加额外的一层 <span class="guilabel">RUN</span> 指令进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <span class="guilabel">RUN</span> 指令进行解压缩。所以不如直接使用 <span class="guilabel">RUN</span> 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">&lt;source_path&gt;</span></code> 为一个 tar 压缩文件的话，压缩格式为 <code class="docutils literal notranslate"><span class="pre">gzip</span></code> <code class="docutils literal notranslate"><span class="pre">bzip2</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">xz</span></code>
的情况下，<span class="guilabel">ADD</span> 指令将会自动解压缩这个压缩文件到 <code class="docutils literal notranslate"><span class="pre">&lt;destination_path&gt;</span></code> 去。</p>
<p>在某些情况下，这个自动解压缩的功能非常游泳，比如官方镜像 <a class="reference external" href="https://github.com/tianon/docker-brew-ubuntu-core/blob/c7e9f7353aa24d1c35f501e06382aed1b540e85f/bionic/Dockerfile">ubuntu Dockerfile</a> 中：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM scratch
ADD ubuntu-bionic-core-cloudimg-amd64-root.tar.gz /
...
</pre></div>
</div>
<p>但在某些情况下，如果我们真的希望复制这个压缩文件进去，而不解压缩，这时就不可以使用 <span class="guilabel">ADD</span> 命令了。</p>
<p>在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 <span class="guilabel">COPY</span>，因为 <span class="guilabel">COPY</span> 的语义很明确，就是复制文件而已，而 <span class="guilabel">ADD</span> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <span class="guilabel">ADD</span> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<span class="guilabel">ADD</span> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <span class="guilabel">COPY</span> 和 <span class="guilabel">ADD</span> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <span class="guilabel">COPY</span> 指令，仅在需要自动解压缩的场合使用 <span class="guilabel">ADD</span>。</p>
</div>
<div class="section" id="cmd">
<h2>CMD 容器启动命令<a class="headerlink" href="#cmd" title="Permalink to this headline">¶</a></h2>
<p><span class="guilabel">CMD</span> 指令的格式和 <span class="guilabel">RUN</span> 相似，也是两种格式：</p>
<ul class="simple">
<li><p><strong>shell</strong> 格式： <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">&lt;command&gt;</span></code></p></li>
<li><p><strong>exec</strong> 格式： <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">[&quot;executable&quot;,</span> <span class="pre">&quot;arg1&quot;,</span> <span class="pre">&quot;arg2&quot;...]</span></code></p></li>
<li><p>参数列表格式： <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">[&quot;arg1&quot;,</span> <span class="pre">&quot;arg2&quot;...]</span></code> 在指定了 <span class="guilabel">ENTRYPOINT</span> 指令后，用 <span class="guilabel">CMD</span> 指定具体的参数。</p></li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<span class="guilabel">CMD</span> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置重的这个默认命令，比如，<a class="reference external" href="https://store.docker.com/images/ubuntu">ubuntu</a> 镜像默认的 <span class="guilabel">CMD</span> 是 <code class="docutils literal notranslate"><span class="pre">/bin/bash</span></code> ，如果我们直接 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--tty</span> <span class="pre">--interactive</span> <span class="pre">ubuntu</span></code> 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--tty</span> <span class="pre">--interactive</span> <span class="pre">ubuntu</span> <span class="pre">cat</span> <span class="pre">/etc/os-release</span></code> 。这就是用 <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/etc/os-release</span></code> 命令替换了默认的 <code class="docutils literal notranslate"><span class="pre">/bin/bash</span></code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <strong>exec</strong> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用 <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> ，而不要使用单引号。</p>
<p>如果使用 <strong>shell</strong> 格式的话，实际的命令会被包装为 <code class="docutils literal notranslate"><span class="pre">sh</span> <span class="pre">-c</span></code> 的参数的形式进行执行。比如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CMD echo $HOME
</pre></div>
</div>
<p>在实际执行中，会将其变更为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]
</pre></div>
</div>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <span class="guilabel">CMD</span> 就不得不提容器中应用在前台执行和后台执行的问题。初学者常常会混淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该在前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <span class="guilabel">CMD</span> 写为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CMD service nginx start
</pre></div>
</div>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其他辅助进程不是它需要关心的东西。</p>
<p>而使用 <code class="docutils literal notranslate"><span class="pre">service</span> <span class="pre">nginx</span> <span class="pre">start</span></code> 命令，则是希望 upstart 以后台守护进程的形式启动 nginx 服务。而刚才说了 <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">service</span> <span class="pre">nginx</span> <span class="pre">start</span></code> 会被理解为 <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">[</span> <span class="pre">&quot;sh&quot;,</span> <span class="pre">&quot;-c&quot;,</span> <span class="pre">&quot;service</span> <span class="pre">nginx</span> <span class="pre">start&quot;</span> <span class="pre">]</span></code> ，因此主进程实际上是 <code class="docutils literal notranslate"><span class="pre">sh</span></code> 。那么当 <code class="docutils literal notranslate"><span class="pre">service</span> <span class="pre">ngin</span> <span class="pre">start</span></code> 命令结束后， <code class="docutils literal notranslate"><span class="pre">sh</span></code> 也就结束了， <code class="docutils literal notranslate"><span class="pre">sh</span></code> 作为住进称退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CMD [ &quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot; ]
</pre></div>
</div>
</div>
<div class="section" id="entrypoint">
<h2>ENTRYPOINT 入口点<a class="headerlink" href="#entrypoint" title="Permalink to this headline">¶</a></h2>
<p><span class="guilabel">ENTRYPOINT</span> 的格式和 <span class="guilabel">RUN</span> 指令格式一样，分别为 <strong>exec</strong> 格式和 <strong>shell</strong> 格式。</p>
<p><span class="guilabel">ENTRYPOINT</span> 的目的和 <span class="guilabel">CMD</span> 一样，都是在指定容器启动程序及参数。<span class="guilabel">ENTRYPOINT</span> 在运行时也可以替代，不过比 <span class="guilabel">CMD</span> 要略显繁琐，需要通过 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span></code> 的参数 <code class="docutils literal notranslate"><span class="pre">--entrypoint</span></code> 来指定。</p>
<p>当指定了 <span class="guilabel">ENTRYPOINT</span> 后，<span class="guilabel">CMD</span> 的含义就发生了改变，不再是直接的运行其命令，而是将 <span class="guilabel">CMD</span> 的内容作为参数传给 <span class="guilabel">ENTRYPOINT</span> 指令，换句话说实际执行时，将变为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;
</pre></div>
</div>
<p>那么有了 <span class="guilabel">CMD</span> 后，为什么还要有 <span class="guilabel">ENTRYPOINT</span> 呢？这种 <code class="docutils literal notranslate"><span class="pre">&lt;ENTRTYPOINT&gt;</span> <span class="pre">&lt;CMD&gt;</span></code> 有什么好处？让我们来看几个场景。</p>
<ul>
<li><p>场景一：让镜像变成像命令一样使用</p>
<blockquote>
<div><p>假设我们需要一个得知自己当前公网IP的镜像，那么可以先用 <span class="guilabel">CMD</span> 来实现：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM ubuntu:16.04
RUN apt-get update \
    &amp;&amp; apt-get install -y curl \
    &amp;&amp; rm -rf /var/lib/apt/lists/*
CMD [&quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot;]
</pre></div>
</div>
<p>假如我们使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span> <span class="pre">--tag=myip</span> <span class="pre">.</span></code> 来构建镜像的话，如果我们需要查询当前公网IP，只需要执行：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container run --rm --name myip_test myip:1.0
当前 IP: 58.246.147.26 来自: 上海市 联通
</pre></div>
</div>
<p>嗯，这么看起来我们好像直接把镜像当作命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <span class="guilabel">CMD</span> 中可以看到实质的命令时 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 参数。那么我们可以直接加入 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 参数给 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">myip</span></code> 吗？</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container run --rm --name myip_test myip:1.0 -i
docker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: \&quot;-i\&quot;: executable file not found in $PATH&quot;: unknown.
</pre></div>
</div>
<p>我们可以看到可执行文件找不到的报错，<code class="docutils literal notranslate"><span class="pre">executable</span> <span class="pre">file</span> <span class="pre">not</span> <span class="pre">found</span></code> 。之前我们说过，跟在镜像名后面的是 command，运行时会替换 <span class="guilabel">CMD</span> 的默认值。因此这里的 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 替换了原来的 <span class="guilabel">CMD</span> ，而不是添加在原来的 <code class="docutils literal notranslate"><span class="pre">curl</span> <span class="pre">-s</span> <span class="pre">http://ip.cn</span></code> 后面。而 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 这参数，我们就必须重新完整的输入这个命令：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker container run --rm --name myip_test myip:1.0 curl -s http://ip.cn -i
HTTP/1.1 200 OK
Date: Thu, 01 Nov 2018 02:59:52 GMT
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Set-Cookie: __cfduid=d8b77ba972fb91bec979f9a212ceca6841541041192; expires=Fri, 01-Nov-19 02:59:52 GMT; path=/; domain=.ip.cn; HttpOnly
Server: cloudflare
CF-RAY: 472b1b9af36b9619-SJC

当前 IP: 58.246.147.26 来自: 上海市 联通
</pre></div>
</div>
<p>这显然不是很好的解决方案，而使用 <span class="guilabel">ENTRYPOINT</span> 就可以解决这个问题。现在我们重新用 <span class="guilabel">ENTRYPOINT</span> 来实现这个镜像：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM ubuntu:16.04

RUN apt-get update \
    &amp;&amp; apt-get install -y curl \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]
</pre></div>
</div>
<p>这次我们再来尝试直接使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">myip</span> <span class="pre">-i</span></code> 。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker container run --rm --name myip_test myip:1.1
当前 IP: 58.246.147.26 来自: 上海市 联通

$ docker container run --rm --name myip_test myip:1.1 -i
HTTP/1.1 200 OK
Date: Thu, 01 Nov 2018 03:17:16 GMT
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Set-Cookie: __cfduid=d89a29d9467d6f00d7856b8a8f22d10791541042236; expires=Fri, 01-Nov-19 03:17:16 GMT; path=/; domain=.ip.cn; HttpOnly
Server: cloudflare
CF-RAY: 472b351850169668-SJC

当前 IP: 58.246.147.26 来自: 上海市 联通
</pre></div>
</div>
<p>可以看到，这次成功了。这是因为当存在 <span class="guilabel">ENTRYPOINT</span> 后，<span class="guilabel">CMD</span> 的内容将会作为参数传给 <span class="guilabel">ENTRYPOINT</span>，而这里 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 就是新的 <span class="guilabel">CMD</span>，因为会作为参数传给 curl，从而达到了我们预期的效果。</p>
</div></blockquote>
</li>
<li><p>场景二：应用运行前的准备工作</p>
<blockquote>
<div><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 <span class="guilabel">root</span> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务之外，其他命令依旧可以使用 root 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 <span class="guilabel">CMD</span> 无关的，无论 <span class="guilabel">CMD</span> 是什么，都需要事先进行一个预处理工作。这种情况下，可以写一个脚本，然后放入 <span class="guilabel">ENTRYPOINT</span> 中执行，而这个脚本会将接收到的参数（也就是 <span class="guilabel">&lt;CMD&gt;</span>）作为命令，在脚本最后执行。比如官方镜像 <a class="reference external" href="https://github.com/docker-library/redis/blob/dc6dc737baa434528ce31948b22b4c6ccc78793a/5.0/Dockerfile">redis Dockerfile</a> 中就是这么做的：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM alpine:3.4
...
RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis
...
ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]

EXPOSE 6379
CMD [ &quot;redis-server&quot; ]
</pre></div>
</div>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <span class="guilabel">ENTRYPOINT</span> 为 <code class="docutils literal notranslate"><span class="pre">docker-entrypoint.sh</span></code> 脚本。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="nb">set</span> -e

<span class="c1"># first arg is `-f` or `--some-option`</span>
<span class="c1"># or first arg is `something.conf`</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">1</span><span class="p">#-</span><span class="si">}</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">]</span> <span class="o">||</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">1</span><span class="p">%.conf</span><span class="si">}</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">set</span> -- redis-server <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
<span class="k">fi</span>

<span class="c1"># allow the container to be started with `--user`</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s1">&#39;redis-server&#39;</span> -a <span class="s2">&quot;</span><span class="k">$(</span>id -u<span class="k">)</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    find . <span class="se">\!</span> -user redis -exec chown redis <span class="s1">&#39;{}&#39;</span> +
    <span class="nb">exec</span> gosu redis <span class="s2">&quot;</span><span class="nv">$0</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
<span class="k">fi</span>

<span class="nb">exec</span> <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>该脚本的内容就是根据 <span class="guilabel">CMD</span> 的内容来判断，如果是 <code class="docutils literal notranslate"><span class="pre">redis-server</span></code> 的话，则切换到 <code class="docutils literal notranslate"><span class="pre">redis</span></code> 用户身份启动服务，否则依旧使用 root 身份执行。比如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker container run --detach --publish-all --name kvstore redis:4.0-alpine
1656bd2427fcc96e3e9dbdaf0e498786ca8817b5bb97e200476c555a117964c5

$ docker container exec kvstore id
uid=0(root) gid=0(root)
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="env">
<h2>ENV 设置环境变量<a class="headerlink" href="#env" title="Permalink to this headline">¶</a></h2>
<p>格式有两种：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ENV</span> <span class="pre">&lt;key&gt;</span> <span class="pre">&lt;value&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENV</span> <span class="pre">&lt;key1&gt;=&lt;value1&gt;</span> <span class="pre">&lt;key2&gt;=&lt;value2&gt;...</span></code></p></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其他指令，如 <span class="guilabel">RUN</span>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ENV VERSION=1.0 DEBUG=on \
    NAME=&quot;Happy Feet&quot;
</pre></div>
</div>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号扩起来的办法，这和 Shell 下的行为是一致的。</p>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ENV NODE_VERSION 7.2.0

RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.gz&quot; \
    &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; \
    &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \
    &amp;&amp; grep &quot;node -v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c - \
    &amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C /usr/local --strip-components=1 \
    &amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \
    &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs
</pre></div>
</div>
<p>在这里先定义了环境变量 <code class="docutils literal notranslate"><span class="pre">NODE_VERSION</span></code> ，其后的 <span class="guilabel">RUN</span> 这层里，多次使用 <code class="docutils literal notranslate"><span class="pre">$NODE_VERSION</span></code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <span class="guilabel">7.2.0</span> 即可，<span class="guilabel">Dockerfile</span> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量的展开：</p>
<ol class="arabic simple">
<li><p>ADD</p></li>
<li><p>COPY</p></li>
<li><p>ENV</p></li>
<li><p>EXPOSE</p></li>
<li><p>LABEL</p></li>
<li><p>USER</p></li>
<li><p>WORKDIR</p></li>
<li><p>VOLUME</p></li>
<li><p>STOPSIGNAL</p></li>
<li><p>ONBUILD</p></li>
</ol>
<p>可以从这个指令列表感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <span class="guilabel">Dockerfile</span> 制作更多的镜像，只需使用不同的环境变量即可。</p>
</div>
<div class="section" id="arg">
<h2>ARG 构建参数<a class="headerlink" href="#arg" title="Permalink to this headline">¶</a></h2>
<p>格式： <code class="docutils literal notranslate"><span class="pre">ARG</span> <span class="pre">&lt;parameter&gt;[=&lt;defaults&gt;]</span></code></p>
<p>构建参数和 <span class="guilabel">ENV</span> 的效果一样，都是设置环境变量。所不同的是，<span class="guilabel">ARG</span> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <span class="guilabel">ARG</span> 保存密码之类的信息，因为 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">history</span> <span class="pre">IMAGE:TAG</span></code> 还是可以看到所有值的。</p>
<p><span class="guilabel">Dockerfile</span> 中的 <span class="guilabel">ARG</span> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 中用 <code class="docutils literal notranslate"><span class="pre">--build-arg</span> <span class="pre">&lt;parameter&gt;=&lt;value&gt;</span></code> 来覆盖。</p>
<p>在 <strong>1.13</strong> 之前的版本，要求 <code class="docutils literal notranslate"><span class="pre">--build-arg``中的参数名，必须在</span> <span class="pre">:guilabel:`Dockerfile`</span> <span class="pre">中用</span> <span class="pre">:guilabel:`ARG`</span> <span class="pre">定义过了，换句话说，就是</span> <span class="pre">``--build-arg</span></code> 指定的参数，必须在 <span class="guilabel">Dockerfile</span> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 <strong>1.13</strong> 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <span class="guilabel">Dockerfile</span> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p>
</div>
<div class="section" id="volume">
<h2>VOLUME 定义匿名卷<a class="headerlink" href="#volume" title="Permalink to this headline">¶</a></h2>
<p>格式为：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">VOLUME</span> <span class="pre">[&quot;&lt;path1&gt;&quot;,</span> <span class="pre">&quot;path2&quot;...]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VOLUME</span> <span class="pre">&lt;path&gt;</span></code></p></li>
</ul>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷（volume）中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <span class="guilabel">Dockerfile</span> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>VOLUME /data
</pre></div>
</div>
<p>这里的 <code class="docutils literal notranslate"><span class="pre">/data</span></code> 目录就会在运行时自动挂载为匿名卷，任何向 <code class="docutils literal notranslate"><span class="pre">/data</span></code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container --detach --volume mydata:/data xxxx
</pre></div>
</div>
<p>在这行命令中，就使用了 <code class="docutils literal notranslate"><span class="pre">mydata</span></code> 这个命名卷挂载到了 <code class="docutils literal notranslate"><span class="pre">/data</span></code> 这个位置，替代了 <span class="guilabel">Dockerfile</span> 中定义的匿名卷的挂载配置。</p>
</div>
<div class="section" id="expose">
<h2>EXPOSE 声明端口<a class="headerlink" href="#expose" title="Permalink to this headline">¶</a></h2>
<p>格式为 <code class="docutils literal notranslate"><span class="pre">EXPOSE</span> <span class="pre">&lt;port_1&gt;</span> <span class="pre">[&lt;port_2&gt;...]</span></code></p>
<p><span class="guilabel">EXPOSE</span> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 <span class="guilabel">Dockerfile</span> 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用户则是在运行时使用随机端口映射时，也就是 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">run</span> <span class="pre">--publish-all</span></code> 时，会自动随机映射 <span class="guilabel">EXPOSE</span> 的端口。</p>
<p>此外，在早期 Docker 版本中还有一个特殊的用处。以前所有的容器都运行于默认桥接网络中，因此所有容器相互之间都可以之间访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 <code class="docutils literal notranslate"><span class="pre">--icc=false</span></code> ，当指定该参数后，容器间将默认无法互相访问，除非互相之间使用了 <code class="docutils literal notranslate"><span class="pre">--links</span></code> 参数的容器才可以互通，并且只有镜像中 <span class="guilabel">EXPOSE</span> 所声明的端口才可以被访问。这个 <code class="docutils literal notranslate"><span class="pre">--icc=false</span></code> 的用法，在引入了 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">network</span></code> 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联于隔离。</p>
<p>要将 <span class="guilabel">EXPOSE</span> 和在运行时使用 <code class="docutils literal notranslate"><span class="pre">--publish</span> <span class="pre">port_list</span></code> 区分开来。<code class="docutils literal notranslate"><span class="pre">--publish</span></code> 是映射宿主机端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <span class="guilabel">EXPOSE</span> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主机进行端口映射。</p>
</div>
<div class="section" id="workdir">
<h2>WORKDIR 指定工作目录<a class="headerlink" href="#workdir" title="Permalink to this headline">¶</a></h2>
<p>格式为 <code class="docutils literal notranslate"><span class="pre">WORKDIR</span> <span class="pre">&lt;work</span> <span class="pre">directory</span> <span class="pre">path&gt;</span></code></p>
<p>使用 <span class="guilabel">WORKDIR</span> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<span class="guilabel">WORKDIR</span> 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> 等同于 Shell 脚本来书写，这种错误的理解还能会导致出现下面这样的错误：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RUN cd /app
RUN echo &quot;hello&quot; &gt; world.txt
</pre></div>
</div>
<p>如果将这个 “Dockerfile” 进行构建镜像运行后，会发现找不到 <code class="docutils literal notranslate"><span class="pre">/app/world.txt</span></code> 文件，或者其内容不是 hello。其原因很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <span class="guilabel">Dockerfile</span> 中，这两行 <span class="guilabel">RUN</span> 命令在执行环境根本不同，式两个完全不同的容器。这就是对 <span class="guilabel">Dockerfile</span> 构建分层存储的概念不了解所导致的。</p>
<p>之前说过每一个 <span class="guilabel">RUN</span> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">cd</span> <span class="pre">/app</span></code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没有关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code> 指令。</p>
</div>
<div class="section" id="user">
<h2>USER 指定当前用户<a class="headerlink" href="#user" title="Permalink to this headline">¶</a></h2>
<p>格式： <code class="docutils literal notranslate"><span class="pre">USER</span> <span class="pre">&lt;username&gt;</span></code></p>
<p><span class="guilabel">USER</span> 指令和 <span class="guilabel">WORKDIR</span> 相似，都是改变环境状态并影响以后的层。<span class="guilabel">WORKDIR</span> 是改变工作目录，<span class="guilabel">USER</span> 则是改变之后层的执行 <span class="guilabel">RUN</span> 指令，<span class="guilabel">CMD</span> 以及 <span class="guilabel">ENTRYPOINT</span> 这类命令的身份。</p>
<p>当然，和 <span class="guilabel">WORKDIR</span> 一样，<span class="guilabel">USER</span> 只是帮助你切换指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis
USER redis
RUN [ &quot;redis-server&quot; ]
</pre></div>
</div>
<p>如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo ，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># 建立 redis 用户，并使用 gosu 换另一个用户执行命令
RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis
# 下载 gosu
RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \
    &amp;&amp; chmod +x /usr/local/bin/gosu \
    &amp;&amp; gosu nobody true
# 设置 CMD，并以另外的用户执行
CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]
</pre></div>
</div>
</div>
<div class="section" id="healthcheck">
<h2>HEALTHCHECK 健康检查<a class="headerlink" href="#healthcheck" title="Permalink to this headline">¶</a></h2>
<p>格式：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">[option]</span> <span class="pre">CMD</span> <span class="pre">&lt;COMMAND&gt;</span></code> 设置检查容器监控状态的命令</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">NONE</span></code> 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</p></li>
</ul>
<p><span class="guilabel">HEALTHCHECK</span> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是从 <strong>Docker 1.12</strong> 引入的新指令。</p>
<p>在没有 <span class="guilabel">HEALTHCHECK</span> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下没有问题，但是如果程序进入了死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 <strong>1.12</strong> 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 <strong>1.12</strong> 之后，Docker 提供了 <span class="guilabel">HEALTHCHECK</span> 指令后，用其启动容器，初始状态会为 <span class="guilabel">starting</span>，在 <span class="guilabel">HEALTHCHECK</span> 指令检查成功后变为 <span class="guilabel">healthy</span> ，如果连续一定次数失败，则会变为 <span class="guilabel">unhealthy</span>。</p>
<p><span class="guilabel">HEALTHCHECK</span> 支持下列选项：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">--interval=&lt;second&gt;</span></code> 两次健康检查的间隔，默认为 30 秒；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--timeout=&lt;second&gt;</span></code> 健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--retries=&lt;number&gt;</span></code> 当连续失败指定次数后，则将容器状态视为 <span class="guilabel">unhealthy</span>，默认 3 次。</p></li>
</ul>
<p>和 <span class="guilabel">CMD</span> <span class="guilabel">ENTRYPOINT</span> 一样，<span class="guilabel">HEALTHCHECK</span> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">[option]</span> <span class="pre">CMD</span></code> 后面的命令，格式和 <span class="guilabel">ENTRYPOINT</span> 一样，分为 <strong>shell</strong> 格式，和 <strong>exec</strong> 格式。命令的返回值决定了该次健康检查的成功与否</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>code</p></th>
<th class="head"><p>status</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>success</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>fail</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>save</p></td>
</tr>
</tbody>
</table>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>不要使用 2 这个值</p>
</div>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 <span class="guilabel">Dockerfile</span> 的 <span class="guilabel">HEALTHCHECK</span> 可以这么写：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM nginx:1.14.0

RUN apt-get update \
    &amp;&amp; apt-get install -y curl \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

HEALTHCHECK --interval=5s --timeout=3s \
        CMD curl -fs http://localhost/ || exit 1
</pre></div>
</div>
<p>这里我们设置了每5秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过3秒没有响应就视为失败，并且使用 <code class="docutils literal notranslate"><span class="pre">curl</span> <span class="pre">-fs</span> <span class="pre">http://localhost/</span> <span class="pre">||</span> <span class="pre">exit</span> <span class="pre">1</span></code> 作为健康检查命令。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">image</span> <span class="pre">build</span></code> 来构建这个镜像：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker image build --tag=myweb:1.0 .
</pre></div>
</div>
<p>构建完成之后，我们启动一个容器：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>container run --detach --publish 80:80 --name myweb_test myweb:1.0
</pre></div>
</div>
<p>当运行该镜像后，可以通过 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">ls</span></code> 看到最初的状态为 <code class="docutils literal notranslate"><span class="pre">(health:</span> <span class="pre">starting)</span></code> ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container ls
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                   PORTS                     NAMES
6d9d2d0557de        myweb:1.0           &quot;nginx -g &#39;daemon of…&quot;   10 seconds ago      Up 9 seconds (healthy)   0.0.0.0:80-&gt;80/tcp        myweb_test
</pre></div>
</div>
<p>在等待几秒钟后，再次 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">ls</span></code> 就会看到健康状态变化为了 <code class="docutils literal notranslate"><span class="pre">(healthy)</span></code> ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container ls
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS                     NAMES
6d9d2d0557de        myweb:1.0           &quot;nginx -g &#39;daemon of…&quot;   22 seconds ago      Up 21 seconds (healthy)   0.0.0.0:80-&gt;80/tcp        myweb_test
</pre></div>
</div>
<p>如果健康检查连续失败超过了重试次数，状态就会变为 <code class="docutils literal notranslate"><span class="pre">(unhealthy)</span></code> 。</p>
<p>为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr） 都会被存储在健康状态里，可以用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">container</span> <span class="pre">inspect</span> <span class="pre">CONTAINER</span></code> 来查看。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docker container inspect --format &#39;{{json .State.Health}}&#39; myweb_test | python -m json.tool
{
    &quot;Status&quot;: &quot;healthy&quot;,
    &quot;FailingStreak&quot;: 0,
    &quot;Log&quot;: [
        {
            &quot;Start&quot;: &quot;2018-11-01T09:13:48.06308Z&quot;,
            &quot;End&quot;: &quot;2018-11-01T09:13:48.1525581Z&quot;,
            &quot;ExitCode&quot;: 0,
            &quot;Output&quot;: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\&quot;http://nginx.org/\&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\&quot;http://nginx.com/\&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;
        },
        ...
    ]
}
</pre></div>
</div>
</div>
<div class="section" id="onbuild">
<h2>ONBUILD 为他人做嫁衣裳<a class="headerlink" href="#onbuild" title="Permalink to this headline">¶</a></h2>
<p>格式： <code class="docutils literal notranslate"><span class="pre">ONBUILD</span> <span class="pre">&lt;other_instruction&gt;</span></code></p>
<p><span class="guilabel">ONBUILD</span> 是一个特殊的指令，它后面跟的是其他指令，比如 <span class="guilabel">RUN</span>，<span class="guilabel">COPY</span> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p><span class="guilabel">Dockerfile</span> 中的其他指令都是为了定制当前镜像而准备的，唯有 <span class="guilabel">ONBUILD</span> 是为了帮助别人定制自己而准备的。</p>
<p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里 文件里。在拿到程序代码后，需要先进行 <code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">install</span></code> 才可以获取所有需要的依赖。然后就可以通过 <code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">start</span></code> 来启动应用。因此，一般来说会这样写 <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM node:slim

RUN mkdir /app
WORKDIR /app
COPY ./package.json /app
RUN [&quot;npm&quot;, &quot;install&quot;]
COPY . /app/
CMD [&quot;npm&quot;, &quot;start&quot;]
</pre></div>
</div>
<p>把这个 <span class="guilabel">Dockerfile</span> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <span class="guilabel">Dockerfile</span> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 <span class="guilabel">Dockerfile</span> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <span class="guilabel">Dockerfile</span> ，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <span class="guilabel">Dockerfile</span> 是复制、黏贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <span class="guilabel">Dockerfile</span>，而第二个项目的 <span class="guilabel">Dockerfile</span> 就会被自动修复。</p>
<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <span class="guilabel">Dockerfile</span> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <span class="guilabel">Dockerfile</span> 就会变为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM node:slim

RUN mkdir /app
WORKDIR /app
CMD [&quot;npm&quot;, &quot;start&quot;]
</pre></div>
</div>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code class="docutils literal notranslate"><span class="pre">my-node</span></code> 的话，各个项目内的自己的 <span class="guilabel">Dockerfile</span> 就变为：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM my-node
COPY ./package.json /app
RUN [&quot;npm&quot;, &quot;install&quot;]
COPY . /app
</pre></div>
</div>
<p>基础镜像变化后，各个项目都用这个 <span class="guilabel">Dockerfile</span> 重新构建镜像，会继承基础镜像的更新。</p>
<p>那么，问题解决了吗？没有。准确说，只解决了一半。如果这个 <span class="guilabel">Dockerfile</span> 里面有些东西需要调整呢？比如 <code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">install</span></code> 都需要加一些参数，那怎么办？这一行 <span class="guilabel">RUN</span> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code class="docutils literal notranslate"><span class="pre">./package.json</span></code> ，难道又要一个个修改吗？所以说，这样制作基础镜像，只解决了原来的 <span class="guilabel">Dockerfile</span> 的前四条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>
<p><span class="guilabel">ONBUILD</span> 可以解决这个问题。让我们用 <span class="guilabel">ONBUILD</span> 重新写一下基础镜像的 <span class="guilabel">Dockerfile</span>：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM node:slim

RUN mkdir /app
WORKDIR /app
ONBUILD COPY ./package.json /app
ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]
ONBUILD COPY . /app/
CMD [ &quot;npm&quot;, &quot;start&quot; ]
</pre></div>
</div>
<p>这次我们回到原始的 <span class="guilabel">Dockerfile</span>，但是这次将项目相关的指令加上 <span class="guilabel">ONBUILD</span>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <span class="guilabel">Dockerfile</span> 就变成了简单的：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FROM my-node
</pre></div>
</div>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <span class="guilabel">Dockerfile</span> 构建镜像时，之前基础镜像的那三行 <span class="guilabel">ONBUILD</span> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对项目执行 <code class="docutils literal notranslate"><span class="pre">npm</span> <span class="pre">install</span></code> ，生成应用镜像。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../docker/docker.html" class="btn btn-neutral float-left" title="Docker" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Renkeju

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>